#

[TOC]


## 二、操作系统
>> [参考博客：5万字、97 张图总结操作系统核心知识点](https://www.cnblogs.com/cxuanBlog/p/13297199.html)
[我和面试官之间关于操作系统的一场对弈](https://www.cnblogs.com/javaguide/p/operating-system.html)
### 1.[参考资料：操作系统总结](https://www.cnblogs.com/blknemo/p/12274600.html)
#### 1.基础概念：并发&并行，共享，虚拟，同步&异步，阻塞&非阻塞【5+】
```markdown
**并发**是指宏观上在一段时间内能同时运行多个程序，而**并行**则指两个进程同时运行。
    并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。操作系统通过引入进程和线程，使得程序能够并发运行。
**共享**是指系统中的资源可以被多个并发进程共同使用。有两种共享方式：互斥共享和同时共享。
    互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
**虚拟技术**把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。
    多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
**虚拟内存**使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，
    地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
**同步**：当一个同步调用发出后，调用者要一直等待返回结果通知后，才能进行后续的执行。
**异步**：当一个异步过程调用发出后，不必阻塞性地等待返回值或消息。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    1、同步的执行效率会比较低，耗费时间，但有利于我们对流程进行控制，避免很多不可掌控的意外情况。
    2、异步的执行效率高，节省时间，但是会占用更多的资源，也不利于我们对进程进行控制。
**阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞。
**非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程。
```
#### 2.计算机硬件（冯诺伊曼的体系结构）
```markdown
计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：运算器、控制器、存储器、输入设备、输出设备。
运算器：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。
    运算器的基本运算包括加、减、乘、除、移位等操作，这些是由算术逻辑单元(Arithmetic&logical Unit) 实现的。
    而运算器主要由算数逻辑单元和寄存器构成。
控制器：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。
    控制器是由程序计数器、指令寄存器、解码译码器等构成。
**运算器和控制器共同组成了CPU**
存储器：存储器就是计算机的记忆设备，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，
    它是CPU主要交互对象，还有一种是外存，比如硬盘软盘等。
输入设备：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。
输出设备：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。
总线(Buses)：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是字(word)。
    字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。
I/O设备(I/O Devices)：Input/Output设备是系统和外部世界的连接。I/O设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，
    一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。
```
#### 3.用户态和核心态
```markdown
在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、内核态
    用户态：只能受限的访问内存，运行所有的应用程序。
    内核态：运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备。
为什么要有用户态和内核态：
​   **由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络。**
数据怎样从用户空间进入到内核空间？又怎么从内核空间到内存空间？或者说，应用进程如何从内核空间拿数据？
用户态切换到内核态的3种方式：
​ a. 系统调用
    ​ 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，
     比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
​ b. 异常
    ​ 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
​ c. 外围设备的中断
    ​ 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，
     如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
```
#### 4 什么是操作系统？
```markdown
操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；
    操作系统本质上是运行在计算机上的软件程序 ；
    操作系统为用户提供一个与系统交互的操作界面 ；
    操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。
操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型
    文件：对 I/O 设备的抽象
    虚拟内存：对程序存储器的抽象
    进程：对一个正在运行程序的抽象
    虚拟机：对整个操作系统的抽象
```
#### 5 什么是系统调用呢？ 
```markdown
操作系统提供的函数就被称为**系统调用**（system call）。软件程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，
    比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，就是系统调用。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：
    用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。（软件程序运行）
    内核态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。（操作系统运行）
在我们运行的用户程序中，凡是与系统态（内核态）级别的资源有关的操作（如文件管理、进程控制、内存管理等)，
    都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号
    对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。
    比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
系统调用有哪些
    设备管理。完成设备的请求或释放，以及设备启动等功能。
    文件管理。完成文件的读、写、创建及删除等功能。
    进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
    进程通信。完成进程之间的消息传递或信号传递等功能。
    内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。
```
#### 6 进程和线程的区别，协程【10+】
>> 协程与线程以及进程的关系见下图所示。
![](https://mmbiz.qpic.cn/mmbiz_png/vt35KeC5pmicicicIJf2WxuicHibZgtyC6a71ch4SRJvfB5q4PVPzAXh3ibwqm9aPUicUuqNMfxudiacBur8oib0PR1G6zw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
```markdown
​进程：是资源分配的最小单位，是程序的执行过程，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，
    但每个线程又有属于自己的本地方法栈、虚拟机栈、程序计数器。
​线程：是任务调度和执行的最小单位，线程间可能存在相互影响，执行开销较小，不利于资源的管理和保护，
    线程间是共享进程中的资源的。
协程：是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。
    协程不是被操作系统内核所管理，而完全是由程序所控制。
**拥有资源**：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
**调度**：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
**系统开销**：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，所付出的开销远大于创建或撤销线程时的开销。
    类似地，在进行进程切换时，涉及当前执行进程CPU环境的保存及新调度进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
**通信方面**：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。
>> 为什么有了进程还要线程：进程如果被阻塞，哪些等待资源执行的进程就无法执行。进程同一时间只能做一件事。
```
#### 7 进程有哪几种状态【2+】
```markdown
创建状态(new) ：进程正在被创建，尚未到就绪状态。
就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。
阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
```
#### 8 进程间的通信方式【5+】
[进程间通信](https://www.cnblogs.com/xiaolincoding/p/13402297.html)
```markdown
进程间通信目的：保证先后顺序、依赖关系、消息传递。
**信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；（Linux系统上输入kill -l来列出系统使用的信号）
**管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
    在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。（shell中的管线pipelines就是用管道实现的）
**命名管道(Names Pipes)**: 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。
    有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
**消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。
    管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）
    不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。
    消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
**信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
**共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。
    这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
**套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，
    可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
管道：速度慢，容量有限，只有父子进程能通讯。
FIFO：任何进程间都能通讯，但速度慢。
消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
信号量：不能传递复杂消息，只能用来同步。
共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。
```
#### 9 线程间的同步的方式【5+】
```markdown
**同步与互斥**：同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。
    线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。
**信号量(Semphares)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
    信号量是E.W.Dijkstra在1965年提出的一种方法，它使用一个整形变量来累计唤醒次数，以供之后使用。在他的观点中，有一个新的变量类型称作信号量(semaphore)。
    一个信号量的取值可以是0，或任意正数。0表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。
    Dijkstra 提出了信号量有两个操作，现在通常使用down和up（分别可以用sleep和wakeup来表示）。down这个指令的操作会检查值是否大于0 。
    如果大于0，则将其值减1；若该值为0，则进程将睡眠，而且此时down操作将会继续执行。检查数值、修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的原子操作(atomic action)完成。
**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会
    被多个线程同时访问。比如Java中的synchronized关键词和各种Lock都是这种机制。
    互斥量是一个处于两种状态之一的共享变量：解锁(unlocked)和加锁(locked)。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个 整型(integer)来表示。
    0表示解锁，其他所有的值表示加锁，比1大的值表示加锁的次数。
**事件(Event) :Wait/Notify**：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操。
**临界区**：对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
```
#### 10.进程的调度算法/CPU调度算法【5+】
```markdown
**批处理系统**:批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
    **先到先服务(FCFS)调度算法**:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
    **最短作业优先(SJF)的调度算法**:从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
    **时间片轮转调度算法**:时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR(Roundrobin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
    **高响应比优先级调度**高响应比优先（HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，
    **最高优先级调度算法**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以FCFS方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。
    **多级反馈队列调度算法**:是「时间片轮转算法」和「最高优先级算法」的综合和发展。
**交互式系统**
    **时间片轮转**:将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。
        当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。
    **优先级调度**:为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。
    **多级反馈队列**:可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。
**实时系统**:实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。
```
#### 11.死锁【5+】
```markdown
大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为资源(resource)。
资源主要分为：可抢占资源和不可抢占资源
死锁：如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁。
死锁的必要条件：
     互斥条件 (Mutual exclusion)：资源不能被共享，只能由一个进程使用。
     请求与保持条件 (Hold and wait)：已经得到资源的进程可以再次申请新的资源。
     不可剥夺 (No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
     循环等待条件 (Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁。
死锁的处理策略：
     鸵鸟策略：忽略死锁带来的影响
     死锁检测与死锁恢复（检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题）
        从死锁中恢复：通过抢占进行恢复,通过回滚进行恢复,杀死进程恢复。
     死锁预防（通过仔细分配资源来避免死锁）
        破坏互斥条件：没必要的。。。因为我们本身就要互斥
        破坏等待和持有条件：执行前将所有的资源全部分给他
        破坏不可剥夺条件：也就是如果请求不到资源，就主动放弃自己现在持有的资源
        破坏循环等待条件：给资源统一编号，进程只能按编号顺序来请求资源。
     死锁避免（通过破坏死锁产生的四个条件之一来避免死锁）
        单个资源的银行家算法，破坏死锁，破坏互斥条件，破坏保持等待的条件，破坏不可抢占条件，破坏循环等待条件。
[PV操作经典例题——哲学家进餐问题](https://blog.csdn.net/Yun_Ge/article/details/89177918)
```
#### 12.操作系统内存管理方式，分页分段以及段页式的优缺点【5+】
[操作系统-内存管理](https://blog.csdn.net/qq_29677867/article/details/91038642)
```markdown
内存管理方式：块式管理、页式管理、段式管理、段页式管理
    虚拟内存：目的是为了让物理内存扩充为更大的逻辑内存，从而让程序获得更大的可用内存。
    分页系统内存映射：内存管理单元管理者地址空间和物理内存否转换,其中的页表存储着页(程序地址空间)和页框(物理内存空间)的映射表。
    页面置换算法：OPT,LRU,NRU，FIFO，第二次机会算法，CLOCK
0.块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。
    这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
1.页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
2.段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。
    一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
3.段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。
分段和分页的区别：页是定长的，段是不定长的。页是物理单位，段是逻辑单位。
```
#### 13.CPU的上下文切换有几种？系统中断进行了几次上下文切换？【5+】
```markdown
上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。是内核（操作系统的核心）在CPU上对进程或者线程进行切换。
    操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。
    其实际含义是任务切换, 或者CPU寄存器切换。当多任务内核决定运行另外的任务时, 它保存正在运行任务的当前状态, 也就是CPU寄存器中的全部内容。
    这些内容被保存在任务自己的堆栈中, 入栈工作完成后就把下一个将要运行的任务的当前状况从该任务的栈中重新装入CPU寄存器, 并开始下一个任务的运行, 这一过程就是context switch。
    **上下文频繁的切换，会带来一定的性能开销。**
CPU的上下文切换分三种：**进程上下文切换、线程上下文切换、中断上下文切换**。
     系统调用过程中也会发生CPU上下文切换。CPU寄存器会先保存用户态的状态，然后加载内核态相关内容。
    系统调用结束之后，CPU寄存器要恢复原来保存的用户态，继续运行进程。所以，一次系统调用，发生两次CPU上下文切换。
     进程是由内核管理和调度的，进程的切换只能发生在内核态。进程上下文切换与系统调用的不同在于，
    进程的调用会保存用户空间的虚拟内存，全局变量等信息，但是系统调用的上下文则不会，因为其未发生进程的变化。
     内核中的任务调度实际是在调度线程，进程只是给线程提供虚拟内存、全局变量等资源。
    线程上下文切换时，共享相同的虚拟内存和全局变量等资源不需要修改。
    而线程自己的私有数据，如栈和寄存器等，上下文切换时需要保存。
减少上下文切换开销方法:
    - 无锁并发编程
        多线程竞争锁时，会引起上下文切换，所以多个线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据
    - CAS
        Java的Atomic包使用CAS算法来更新数据，而不需要加锁
    - 控制线程数
        避免创建过多不需要的线程，当任务少的时候，但是创建很多线程来处理，这样会造成大量线程都处于等待状态
    - 协程(GO语言)
        在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
```
#### 14.内存页面置换算法【5+】
```markdown
 **最优页面置换算法**：最理想的状态下，置换在「未来」最长时间不访问的页面。
 **先进先出页面置换算法（FIFO）**：选择在内存驻留时间很长的页面进行中置换。
 **最近最少使用页面置换算法LRU**：选择最长时间没有被访问的页面进行置换。
 **第二次机会页面置换算法**：FIFO链表页面有个缺陷，那就是出链和入链并不会进行check检查，这样就会容易把经常使用的页面置换出去。
 **时钟页面置换算法**：当缺页错误出现时，算法首先检查表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；
 **最不常用（LFU）算法**：当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。
```
#### 15.虚拟地址，逻辑地址，物理地址的关系【5+】
```markdown
1)虚拟地址：是由程序产生的由段选择符和段内偏移地址组成的地址。
    这2部分组成的地址并不能直接访问物理内存，而是要通过分段地址的变化处理后才会对应到相应的物理内存地址。
2)逻辑地址：指由程序产生的段内偏移地址。逻辑地址与虚拟地址二者之间没有明确的界限。
3)线性地址：指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。
    程序代码会产生逻辑地址，或者说段中的偏移地址，加上相应段基址就成了一个线性地址。
    如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。
4)物理地址：指内存中物理单元的集合，他是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。。
    逻辑（虚拟）地址经过分段（查询段表）转化为线性地址。线性地址经过分页（查询页表）转为物理地址。
```
#### 16.磁盘调度算法
[大厂面试爱问的「调度算法」，20 张图一举拿下](https://www.cnblogs.com/xiaolincoding/p/13631224.html)
```markdown
**先来先服务算法**
**最短寻道时间优先算法**的工作方式是，优先选择从当前磁头位置所需寻道时间最短的请求
**扫描算法**
**循环扫描算法**
**LOOK与C-LOOK算法**
```
#### 17.孤儿进程&僵尸进程
```markdown
孤儿进程
    一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
    孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。
    由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。
僵尸进程
    一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过wait()或waitpid()获取了子进程信息后才会释放。
        如果子进程退出，而父进程并没有调用wait()或waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。
    僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。
    系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
    要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。
```