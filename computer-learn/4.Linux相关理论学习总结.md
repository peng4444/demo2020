# Linux相关理论学习总结
[参考资料：极客时间趣谈Linux操作系统](https://www.baidu.com)

[TOC]


##
### Linux学习过程
![image-20201121143610963](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121143618.png)
```markdown
熟练使用Linux命令行、使用Linux进行程序设计、了解Linux内核机制、阅读Linux内核代码、实验定制Linux组件，以及最后落到生产实践上。
    《鸟哥的Linux私房菜》
    先读《UNIX 环境高级编程》，后读的《Unix/Linux编程实践教程》
    《庖丁解牛Linux内核分析》
```
### 双击鼠标打开QQ
![image-20201121145051750](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121145051.png)
```markdown
“双击鼠标打开QQ”这样一个简单的操作，它几乎涵盖了操作系统的所有功能。
1.“双击 QQ”这个过程，都需要用到哪些硬件？
    - 鼠标和键盘是计算机的输入设备。输入设备驱动
    - 屏幕，也就是显示器，是计算机的输出设备。显卡，显卡驱动，在操作系统中称为输出设备驱动。
2.文件管理子系统（File Management Subsystem），程序（Program），进程（Process），系统调用（System Call）
    进程管理子系统（Process Management Subsystem），内存管理子系统（Memory Management Subsystem），
```
### 操作系统内核体系结构图
![image-20201121145248073](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121145248.png)
### Linux简单使用
[centos创建新用户](https://blog.csdn.net/nieji3057/article/details/79421874)
```markdown
$ useradd pbj    // 创建新用户
$ passwd pbj centos101  // 为新用户设置密码
$ useradd -h  // 查看帮助 或者man useradd
Linux 也有自己的软件管家，CentOS 下面是 yum，Ubuntu 下面是 apt-get。
    对于 CentOS 来讲，配置文件在/etc/yum.repos.d/CentOS-Base.repo里。
    对于 Ubuntu 来讲，配置文件在/etc/apt/sources.list里。
Linux执行程序
    最常用的一种方式，通过shell在交互命令行里面运行。
    Linux运行程序的第二种方式，后台运行。使用nohup命令
        $ nohup command >out.file 2>&1 & 
        1表示文件描述符1，表示标准输出，2表示文件描述符2，意思是标准错误输出，2>&1表示标准输出和错误输出合并out.file
    程序运行的第三种方式，以服务的方式运行。
```
### 系统调用
```markdown
进程管理：
    在Linux里，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
    当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。
    对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。
内存管理：
    在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。
    对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）。
    对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（Data Segment）。
    其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；
    也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。
文件管理：
信号处理：
进程间通信：
网络通信：
```
###
[全方位剖析Linux操作系统](https://www.cnblogs.com/cxuanBlog/p/13789900.html)
[后端程序员必备的 Linux 基础知识+常见命令](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247493578&idx=2&sn=ae265b5b05204fcb949fee41fd2d7d13&chksm=fc461a39cb31932fcd084bf566f9d2ea9111a7da56cc2a408eac8145e8d5a64f5005e1e2e28b&mpshare=1&scene=23&srcid=0901oUWt9SKi6zFY7iH7oC0d&sharer_sharetime=1598924671509&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[linux服务器负载问题排查](https://www.cnblogs.com/chenfangzhi/p/9981614.html)
[Keepalived 原理与实战](https://www.cnblogs.com/christopherchan/p/12953230.html)
[linux系统下扩展磁盘空间](https://blog.csdn.net/weixin_41229271/article/details/80476648)
[LVM : 扩展文件系统的容量](https://www.cnblogs.com/sparkdev/p/10142629.html)
[如何构建“高性能”“大小无限”（磁盘）队列？](https://www.cnblogs.com/yougewe/p/10988194.html)

### Linux I/O
#### 1.1 五种I/O模型
[带你真正的搞懂，Linux的5种I/O模型](https://www.toutiao.com/a6619988112300835331/)
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO）: 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
I/O复用是通过一种机制，一个进程可以监听多个文件描述符，一旦某个fd就绪（一般是读就绪或写就绪），就通知程序进行相应的操作。
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO多路复用模型select、poll和epoll函数的区别？【5+】
[IO多路复用中select、poll、epoll之间的区别？](https://blog.csdn.net/weixin_44359909/article/details/107795454)
```markdown
目前Linux上主要的I/O多路复用模型有三种，select、poll、epoll，它们本质上都是同步I/O，即要求读写事件就绪后自己负责进行读写，这会导致请求进程阻塞，直到I/O操作完成。
select、poll、eopll是操作系统处理网络上传输过来的数据的不同实现，数据从经过网线流入网卡，网卡中的驱动程序会向CPU发出中断信号，
    在交互系统中，中断信号的优先级是很高的，CPU立刻去处理这个中断信息，CPU通过终端表找到相应的处理函数：
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制。
 poll没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
    情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
 epoll通过监控注册的多个描述字，来进行I/O事件的分发处理。不同poll的是，epoll不仅提供了默认的level-triggered（条件触发）机制，还提供了性能更为强劲的edge triggered（边缘触发）机制
```
#### 1.4 BIO、NIO、AIO有什么区别？【3+】
```markdown
BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。(InputStream、OutputStream、Reader、Writer)
NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。
    (Channels、Buffers、Selectors)
AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。
BIO 是一个连接一个线程。,NIO是一个请求一个线程。,AIO是一个有效请求一个线程。
BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
IO多路复用：调用系统级别的select、poll、epoll
```
#### [说了这么多次 I/O，但你知道它的原理么](https://www.cnblogs.com/cxuanBlog/p/13032486.html)
### Linux常用命令【3+】
#### Linux基础命令
```markdown
文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限
    通过df命令可以查看磁盘的剩余空间： df -h -h表示按单位格式化输出。-d指定了递归深度为1层，
    可以使用iostat来查看系统的磁盘I/O状况：iostat -d -k -d表示查看磁盘使用状况，-k表示以KB为单位显示。
    通过vmstat命令，可以查看到Swap I/O的情况： vmstat swap列的si表示每秒从磁盘交换到内存的数据量，单位是KB/s，so表示每秒从内存交换到磁盘的数据量，单位也是KB/s。
进程管理：ps显示进程信息、kill杀死进程
系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况
    w、top、uptime这三个命令都可以用来查看系统的load值，下面演示一下使用uptime命令查看系统的load： uptime
    通过free命令能够查看到系统的内存使用情况，加上-m参数表示以MB为单位：free -m
    linux查看进程所占内存命令: 使用 ps -ef | grep mysql 查看mysql这个进程的id
                            使用 top -p 进程id  查看到进程的CUP和内存的占用率
                            可直接使用ps命令查看： ps -aux | grep kafka 
网络通讯：ping测试网络连通性、netstat显示网络相关信息
Linux 命令，查看文件前十行，后十行 head,tail
端口被占用: lsof -i 端口号
           netstat -ntulp | grep 端口号
统计文件有多少行：
    wc [选项] 文件…
      - c 统计字节数。
      - l 统计行数。
      - w 统计字数。
```
#### Linux中常见的网络命令
[面试官问我Linux下常见网络命令](https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247486142&idx=1&sn=847511b9f15751f35a6bbab631a612a3&chksm=97794e91a00ec78702acc82c35828011f0f98fff3c1b55741372b73c20e26a1f1e6dde70ae5f&mpshare=1&scene=23&srcid=0924Z8afHzXSvX6tbe72caGH&sharer_sharetime=1600910416242&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
        ping www.baidu.com
        ping www.baidu.com -c 6 -i 0.6  其中 –c count 次数，也就是ping的次数；-i interval 间隔 ，每次ping之间的时间空格
    telnet命令用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。
    netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。
        netstat -a     //列出所有端口
        netstat -at    //列出所有tcp端口
        netstat -au    //列出所有udp端口
        netstat -l //只显示监听端口
        netstat -lt //只列出所有监听 tcp 端口
        netstat -lu //只列出所有监听 udp 端口
    ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。
    route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；
        可以在*/etc/rc.local中添加route命令来保证该路由设置永久有效。
    arp命令用于操作主机arp缓冲区，可以显示arp缓冲区的所有条目、删除指定条目或增加静态IP地址与MAC地址的对应关系
        arp -a
        arp -v
    traceroute命令用于追踪数据包在网络上传输时的全部路径，它默认发送的数据包大小是40字节通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。
        traceroute www.baidu.com
    host命令是常用的分析域名查询工具，可以检测域名系统工作是否正常
    tcpdump命令是一款抓取数据包的工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。
```
#### [不可不知的7个JDK命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
javap:使用javap可以查看Java字节码反编译的源文件。
jsp:jps 是用来查询当前所有进程 pid 的。
jstat: jstat 主要用于监控 JVM，主要是 GC 信息，在性能优化的时候经常用到，
jcmd: jcmd 可以查看 JVM 信息。
jmap: jmap 打印出 Java 进程内存中 Object 的情况，或者将 JVM 中的堆以二进制输出成文本。
jhat: jhat 分析 Java 堆的命令，可以将堆中对象以 html 的形式显示出来，支持对象查询语言 OQL
jsatck: jstack 是堆栈跟踪工具，主要用于打印给定进程 pid 的堆栈信息，
    一般在发生死锁或者 CPU 100% 的时候排查问题使用，可以去查询当前运行的线程以及线程的堆栈信息是什么情况
[给你的Java程序拍个片子吧：jstack命令解析](https://www.cnblogs.com/jay-huaxiao/p/12865552.html)
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
#### [1.分析Linux进程的6个方法，我全都告诉你](http://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247487818&idx=3&sn=a7f1dbff16e0f2ff3aa0e5af69a62f1c&chksm=ce405a9ef937d3886a7a3eb7fce31e57ec533b18d80b12559d449ece5c49ec58563398293dd8&mpshare=1&scene=23&srcid=&sharer_sharetime=1590881539719&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ps:  --列出当前系统进程的快照。
   # ps -ef  -- 列出系统内经常信息 
   # ps -ef|grep intresting  -- 第一列PID代表进程号，
strace: --跟踪进程内部的系统调用和信号
    # strace ./time_test  -- strace后面跟着启动一个进程，可以跟踪启动后进程的系统调用和信号
pstack: -- 打印出运行中程序的堆栈信息
    # pstack pid -- 能看到当前线程运行中的堆栈信息
pstree: -- 按树形结构打印运行中进程结构信息
    # pstree -p 11811
gdb: -- 可以查看程序的堆栈、设置断点、打印程序运行时信息，甚至还能调试多线程程序
```
#### [Linux 性能分析之内存篇](https://www.cnblogs.com/bakari/p/10486818.html)
```markdown
内存信息
    1.cat /proc/meminfo 查看文件记录着比较详细的内存配置信息
    2.free
    3.dmidecode -t memory
    4.vmstat l 用于进行系统全局分析和CPU分析
进程内存使用情况分析
    1.top/htop:按照 CPU 利用率进行排序的
    2.ps aux --sort=rss | head -n 查看 Top n 进程占用内存情况
    3.pmap -x pid  查看进程在哪些地方用了多少内存
    
```
#### 日志文件找出现最频繁的k个word，以及考虑大文件分割处理
#### 出现高CPU怎么解决？排查
#### Linux 文件类型
```markdown
Linux 支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
1.普通文件（-）：用于存储信息和数据，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
2.目录文件（d，directory file）：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
3.符号链接文件（l，symbolic link）：保留了指向文件的地址而不是文件本身。
4.字符设备（c，char）：用来访问字符设备比如硬盘。
5.设备文件（b，block）：用来访问块设备比如硬盘、软盘。
6.管道文件(p,pipe):一种特殊类型的文件，用于进程之间的通信。
7.套接字(s,socket)：用于进程间的网络通信，也可以用于本机之间的非网络通信。
```
#### linux命令 对日志文件的IP出现的次数进行统计
```java
grep -i -o -E "([0-9]{1,3}\.){3}[0-9]{1,3}" test1.txt | sort -n | uniq -c | sort -n -r | head -6
grep命令 用于文本搜索

-E：用于使用正则匹配

-o：只显示匹配的部分

-i：忽略大小写

sort命令用于排序

-n：数值排序

-r：倒序排序

uniq命令用于去重

-c：显示重复次数

head -6命令显示前6行
```
#### 如何查找特定的文件
```markdown
语法：find path [options] params  --在指定目录下查找文件
find -name "text.md"  -- 在当前目录下递归查找text.md文件
find / -name "text.md" -- 从根目录开始递归查找text.md文件
find ~ -name "aa*"  --去父目录下递归查找aa开头的文件
find ~ -name "aa*"  --去父目录下递归查找aa开头的文件(不区分文件名大小写去查找文件)
man find: 更多关于find指令的使用说明
```
#### 检索文件内容
```markdown
语法：grep [options] pattern file  作用：查找文件里符合条件的字符串
grep "moo" target*  -- 去当前目录下的target开头文件中查找包含moo的字符
管道操作符 | 将指令连接起来，前一个指令的输出作为后一个指令的输入
find -xxx | grep "abc"
    使用管道注意的要点：
        - 只处理前一个命令正确输出，不处理错误输出
        - 右边命令必须能够接受标准输入流，否则传递过程中数据会被抛弃
        - sed,awk,grep,cut,head,top,less,more,wc,join,sort,split等等
```
#### 对文件内容做统计
```markdown
语法： awk [options] 'cmd' file 一次读取一行，按输入分隔符进行切片
    awk '{print $1,$4}' test.txt 取出test.txt文件中第一个和第四个切片
    awk '$1=="tcp" && $2==1{print $0}' test.txt 取出test.txt文件中第一个和第四个切片
```
#### 批量替换文件内容
```markdown
语法: sed [option] 'sed command' filename  流编辑器 适合对文本的行内容进行处理
    sed -i 's/^Str/String/' text.txt -- 将文件中的Str替换为String并且写入文件（一行文件只替换首次出现的）
    sed -i 's/\.$/\;/'  text.txt -- 将文件中末尾的.替换为;并且写入文件
    sed -i 's/^Str/String/g' text.txt -- 将文件中的Str替换为String并且写入文件（全文替换）
    sed -i '/Integer/d' text.txt --将文件中包含Integer的文件行删除
```