# Linux相关理论学习总结
[参考资料：极客时间趣谈Linux操作系统](https://www.baidu.com)

[TOC]


##
### Linux学习过程
![image-20201121143610963](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121143618.png)
```markdown
熟练使用Linux命令行、使用Linux进行程序设计、了解Linux内核机制、阅读Linux内核代码、实验定制Linux组件，以及最后落到生产实践上。
    《鸟哥的Linux私房菜》
    先读《UNIX 环境高级编程》，后读的《Unix/Linux编程实践教程》
    《庖丁解牛Linux内核分析》
```
### 双击鼠标打开QQ
![image-20201121145051750](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121145051.png)
```markdown
“双击鼠标打开QQ”这样一个简单的操作，它几乎涵盖了操作系统的所有功能。
1.“双击 QQ”这个过程，都需要用到哪些硬件？
    - 鼠标和键盘是计算机的输入设备。输入设备驱动
    - 屏幕，也就是显示器，是计算机的输出设备。显卡，显卡驱动，在操作系统中称为输出设备驱动。
2.文件管理子系统（File Management Subsystem），程序（Program），进程（Process），系统调用（System Call）
    进程管理子系统（Process Management Subsystem），内存管理子系统（Memory Management Subsystem），
```
### 操作系统内核体系结构图
![image-20201121145248073](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121145248.png)
### 系统调用
```markdown
进程管理：
    在Linux里，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
    当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。
    对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。
内存管理：
    在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。
    对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）。
    对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（Data Segment）。
    其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；
    也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。
文件管理：
信号处理：
进程间通信：
网络通信：
```
### 一个进程从代码到二进制到运行时的一个过程（创建进程）
![image-20201123134725509](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201123134732.png)
```markdown
我们首先通过图右边的文件编译过程，生成so文件和可执行文件，放在硬盘上。
上图左边的用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。
这个系统调用会通过 load_elf_binary 方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。
```
### 如何创建线程
![image-20201123135317002](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201123135317.png)
```markdown
一个普通线程的创建和运行过程
    - 声明线程函数
    - 声明线程对象
    - 设置线程属性
    - 创建线程
    - 销毁线程属性
    - 等待线程结束
    - 主线程结束
线程的数据
    - 第一类是线程栈上的本地数据，比如函数执行过程中的局部变量。
    - 第二类数据就是在整个进程里共享的全局数据。例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。
    - 这就是第三类数据，线程私有数据（Thread Specific Data）
如何对线程数据进行保护
    - 线程加锁（互斥锁）
```
### 用户态和内核态，函数栈的工作模式
```markdown
在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？
用户态函数栈
    在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。
内核态函数栈
    Linux给每个task都分配了内核栈。
    当系统调用从用户态到内核态的时候，首先要做的第一件事情，就是将用户态运行过程中的CPU上下文保存起来，
    其实主要就是保存在这个结构的寄存器变量里。这样当从内核系统调用返回的时候，才能让进程在刚才的地方接着运行下去。
    通过task_struct找内核栈，就能够轻松得到内核栈和内核寄存器。
    通过内核栈找task_struct
在Linux里面，进程大概可以分成两种。
    - 一种称为实时进程，也就是需要尽快执行返回结果的那种。
    - 另一种是普通进程，大部分的进程其实都是这种。
调度策略与调度类
    - 实时调度策略
        对于调度策略，其中 SCHED_FIFO、SCHED_RR、SCHED_DEADLINE 是实时进程的调度策略。
        对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。
    - 完全公平调度算法
主动调度是如何发生的？       
    - 主动调度的过程，也即一个运行中的进程主动调用__schedule让出CPU。
    在__schedule里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。
    而上下文切换又分用户态进程空间的切换和内核态的切换。
    - 上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和CPU上下文。
抢占式调度是如何发生的？
    - 最常见的现象就是一个进程执行时间太长了，是时候切换到另一个进程了。
    - 另外一个可能抢占的场景是当一个进程被唤醒的时候。
```



[全方位剖析Linux操作系统](https://www.cnblogs.com/cxuanBlog/p/13789900.html)
[后端程序员必备的 Linux 基础知识+常见命令](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247493578&idx=2&sn=ae265b5b05204fcb949fee41fd2d7d13&chksm=fc461a39cb31932fcd084bf566f9d2ea9111a7da56cc2a408eac8145e8d5a64f5005e1e2e28b&mpshare=1&scene=23&srcid=0901oUWt9SKi6zFY7iH7oC0d&sharer_sharetime=1598924671509&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[linux服务器负载问题排查](https://www.cnblogs.com/chenfangzhi/p/9981614.html)
[Keepalived 原理与实战](https://www.cnblogs.com/christopherchan/p/12953230.html)
[linux系统下扩展磁盘空间](https://blog.csdn.net/weixin_41229271/article/details/80476648)
[LVM : 扩展文件系统的容量](https://www.cnblogs.com/sparkdev/p/10142629.html)
[如何构建“高性能”“大小无限”（磁盘）队列？](https://www.cnblogs.com/yougewe/p/10988194.html)

### Linux I/O
#### 1.1 五种I/O模型
[带你真正的搞懂，Linux的5种I/O模型](https://www.toutiao.com/a6619988112300835331/)
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO）: 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
I/O复用是通过一种机制，一个进程可以监听多个文件描述符，一旦某个fd就绪（一般是读就绪或写就绪），就通知程序进行相应的操作。
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO多路复用模型select、poll和epoll函数的区别？【5+】
[IO多路复用中select、poll、epoll之间的区别？](https://blog.csdn.net/weixin_44359909/article/details/107795454)
```markdown
目前Linux上主要的I/O多路复用模型有三种，select、poll、epoll，它们本质上都是同步I/O，即要求读写事件就绪后自己负责进行读写，这会导致请求进程阻塞，直到I/O操作完成。
select、poll、eopll是操作系统处理网络上传输过来的数据的不同实现，数据从经过网线流入网卡，网卡中的驱动程序会向CPU发出中断信号，
    在交互系统中，中断信号的优先级是很高的，CPU立刻去处理这个中断信息，CPU通过终端表找到相应的处理函数：
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制。
 poll没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
    情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
 epoll通过监控注册的多个描述字，来进行I/O事件的分发处理。不同poll的是，epoll不仅提供了默认的level-triggered（条件触发）机制，还提供了性能更为强劲的edge triggered（边缘触发）机制
```
#### 1.4 BIO、NIO、AIO有什么区别？【3+】
```markdown
BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。(InputStream、OutputStream、Reader、Writer)
NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。
    (Channels、Buffers、Selectors)
AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。
BIO 是一个连接一个线程。,NIO是一个请求一个线程。,AIO是一个有效请求一个线程。
BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
IO多路复用：调用系统级别的select、poll、epoll
```
#### [说了这么多次 I/O，但你知道它的原理么](https://www.cnblogs.com/cxuanBlog/p/13032486.html)
### Linux常用命令【3+】
#### Linux基础命令
```markdown
文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限
    通过df命令可以查看磁盘的剩余空间： df -h -h表示按单位格式化输出。-d指定了递归深度为1层，
    可以使用iostat来查看系统的磁盘I/O状况：iostat -d -k -d表示查看磁盘使用状况，-k表示以KB为单位显示。
    通过vmstat命令，可以查看到Swap I/O的情况： vmstat swap列的si表示每秒从磁盘交换到内存的数据量，单位是KB/s，so表示每秒从内存交换到磁盘的数据量，单位也是KB/s。
进程管理：ps显示进程信息、kill杀死进程
系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况
    w、top、uptime这三个命令都可以用来查看系统的load值，下面演示一下使用uptime命令查看系统的load： uptime
    通过free命令能够查看到系统的内存使用情况，加上-m参数表示以MB为单位：free -m
    linux查看进程所占内存命令: 使用 ps -ef | grep mysql 查看mysql这个进程的id
                            使用 top -p 进程id  查看到进程的CUP和内存的占用率
                            可直接使用ps命令查看： ps -aux | grep kafka 
网络通讯：ping测试网络连通性、netstat显示网络相关信息
Linux 命令，查看文件前十行，后十行 head,tail
端口被占用: lsof -i 端口号
           netstat -ntulp | grep 端口号
统计文件有多少行：
    wc [选项] 文件…
      - c 统计字节数。
      - l 统计行数。
      - w 统计字数。
```
#### Linux中常见的网络命令
[面试官问我Linux下常见网络命令](https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247486142&idx=1&sn=847511b9f15751f35a6bbab631a612a3&chksm=97794e91a00ec78702acc82c35828011f0f98fff3c1b55741372b73c20e26a1f1e6dde70ae5f&mpshare=1&scene=23&srcid=0924Z8afHzXSvX6tbe72caGH&sharer_sharetime=1600910416242&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
        ping www.baidu.com
        ping www.baidu.com -c 6 -i 0.6  其中 –c count 次数，也就是ping的次数；-i interval 间隔 ，每次ping之间的时间空格
    telnet命令用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。
    netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。
        netstat -a     //列出所有端口
        netstat -at    //列出所有tcp端口
        netstat -au    //列出所有udp端口
        netstat -l //只显示监听端口
        netstat -lt //只列出所有监听 tcp 端口
        netstat -lu //只列出所有监听 udp 端口
    ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。
    route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；
        可以在*/etc/rc.local中添加route命令来保证该路由设置永久有效。
    arp命令用于操作主机arp缓冲区，可以显示arp缓冲区的所有条目、删除指定条目或增加静态IP地址与MAC地址的对应关系
        arp -a
        arp -v
    traceroute命令用于追踪数据包在网络上传输时的全部路径，它默认发送的数据包大小是40字节通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。
        traceroute www.baidu.com
    host命令是常用的分析域名查询工具，可以检测域名系统工作是否正常
    tcpdump命令是一款抓取数据包的工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。
```
#### [不可不知的7个JDK命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
javap:使用javap可以查看Java字节码反编译的源文件。
jsp:jps 是用来查询当前所有进程 pid 的。
jstat: jstat 主要用于监控 JVM，主要是 GC 信息，在性能优化的时候经常用到，
jcmd: jcmd 可以查看 JVM 信息。
jmap: jmap 打印出 Java 进程内存中 Object 的情况，或者将 JVM 中的堆以二进制输出成文本。
jhat: jhat 分析 Java 堆的命令，可以将堆中对象以 html 的形式显示出来，支持对象查询语言 OQL
jsatck: jstack 是堆栈跟踪工具，主要用于打印给定进程 pid 的堆栈信息，
    一般在发生死锁或者 CPU 100% 的时候排查问题使用，可以去查询当前运行的线程以及线程的堆栈信息是什么情况
[给你的Java程序拍个片子吧：jstack命令解析](https://www.cnblogs.com/jay-huaxiao/p/12865552.html)
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
#### [1.分析Linux进程的6个方法，我全都告诉你](http://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247487818&idx=3&sn=a7f1dbff16e0f2ff3aa0e5af69a62f1c&chksm=ce405a9ef937d3886a7a3eb7fce31e57ec533b18d80b12559d449ece5c49ec58563398293dd8&mpshare=1&scene=23&srcid=&sharer_sharetime=1590881539719&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ps:  --列出当前系统进程的快照。
   # ps -ef  -- 列出系统内经常信息 
   # ps -ef|grep intresting  -- 第一列PID代表进程号，
strace: --跟踪进程内部的系统调用和信号
    # strace ./time_test  -- strace后面跟着启动一个进程，可以跟踪启动后进程的系统调用和信号
pstack: -- 打印出运行中程序的堆栈信息
    # pstack pid -- 能看到当前线程运行中的堆栈信息
pstree: -- 按树形结构打印运行中进程结构信息
    # pstree -p 11811
gdb: -- 可以查看程序的堆栈、设置断点、打印程序运行时信息，甚至还能调试多线程程序
```
#### [Linux 性能分析之内存篇](https://www.cnblogs.com/bakari/p/10486818.html)
```markdown
内存信息
    1.cat /proc/meminfo 查看文件记录着比较详细的内存配置信息
    2.free
    3.dmidecode -t memory
    4.vmstat l 用于进行系统全局分析和CPU分析
进程内存使用情况分析
    1.top/htop:按照 CPU 利用率进行排序的
    2.ps aux --sort=rss | head -n 查看 Top n 进程占用内存情况
    3.pmap -x pid  查看进程在哪些地方用了多少内存
```
#### 日志文件找出现最频繁的k个word，以及考虑大文件分割处理
#### linux命令 对日志文件的IP出现的次数进行统计
```java
grep -i -o -E "([0-9]{1,3}\.){3}[0-9]{1,3}" test1.txt | sort -n | uniq -c | sort -n -r | head -6
grep命令 用于文本搜索

-E：用于使用正则匹配

-o：只显示匹配的部分

-i：忽略大小写

sort命令用于排序

-n：数值排序

-r：倒序排序

uniq命令用于去重

-c：显示重复次数

head -6命令显示前6行
```
#### 检索文件内容
```markdown
语法：grep [options] pattern file  作用：查找文件里符合条件的字符串
grep "moo" target*  -- 去当前目录下的target开头文件中查找包含moo的字符
管道操作符 | 将指令连接起来，前一个指令的输出作为后一个指令的输入
find -xxx | grep "abc"
    使用管道注意的要点：
        - 只处理前一个命令正确输出，不处理错误输出
        - 右边命令必须能够接受标准输入流，否则传递过程中数据会被抛弃
        - sed,awk,grep,cut,head,top,less,more,wc,join,sort,split等等
```
#### 对文件内容做统计
```markdown
语法： awk [options] 'cmd' file 一次读取一行，按输入分隔符进行切片
    awk '{print $1,$4}' test.txt 取出test.txt文件中第一个和第四个切片
    awk '$1=="tcp" && $2==1{print $0}' test.txt 取出test.txt文件中第一个和第四个切片
```
#### 批量替换文件内容
```markdown
语法: sed [option] 'sed command' filename  流编辑器 适合对文本的行内容进行处理
    sed -i 's/^Str/String/' text.txt -- 将文件中的Str替换为String并且写入文件（一行文件只替换首次出现的）
    sed -i 's/\.$/\;/'  text.txt -- 将文件中末尾的.替换为;并且写入文件
    sed -i 's/^Str/String/g' text.txt -- 将文件中的Str替换为String并且写入文件（全文替换）
    sed -i '/Integer/d' text.txt --将文件中包含Integer的文件行删除
```

## Linux命令总结
[当前标签：每天学习一个linux命令](https://www.cnblogs.com/huchong/tag/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/)
#### 一些实用的快捷键
```markdown
- Ctrl + L 用于清理终端的内容，就是清屏的作用。== clear
- Ctrl + D 给终端传递 EOF （End Of File，文件结束符），在运行程序时很有用。
    比如退出root用户身份，就可以用Ctrl+D。如果在命令行提示符后什么也不输入的情况下直接按下这组快捷键，那么就会关闭当前的终端；
- Shift + PgUp 用于向上滚屏，与鼠标的滚轮向上滚屏是一个效果；
- Shift + PgDn 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果。
- Ctrl + A 光标跳到一行命令的开头。一般来说，Home 键有相同的效果；
- Ctrl + E 光标跳到一行命令的结尾。一般来说，End 键有相同的效果；。
- Ctrl + U 删除所有在光标左侧的命令字符；
- Ctrl + K 删除所有在光标右侧的命令字符；
- Ctrl + W 删除光标左侧的一个“单词”，这里的“单词”指的是用空格隔开的一个字符串。例如 -a 就是一个“单词”；
- Ctrl + Y 粘贴用 Ctrl + U、 Ctrl + K 或 Ctrl + W “删除”的字符串，有点像“剪切-粘贴”。
- Ctrl + R 搜索先前使用的命令
- Ctrl + C 终止当前命令
- ESC + T 调换光标前的两个单词
```
#### 根目录
```markdown
- bin：表示“二进制文件”（我们知道可执行文件是二进制的）。包含了会被所有用户使用的可执行程序；
- boot：包含与 Linux 启动密切相关的文件；
- dev：表示“设备”，包含外设。它里面的子目录，每一个对应一个外设。比如代表我们的光盘驱动器的文件就会出现在这个目录下面；
- etc：表示“…等等”，包含系统的配置文件。至于为什么在/etc下面存放配置文件，按照原始的Unix说法（Linux文件结构参考Unix的教学实现MINIX），这下面放的都是一堆零零碎碎的东西，就叫etc好了。
- home：用户的私人目录。放置私人的文件，有点类似Windows中的Documents这个文件夹，也叫“我的文档”。Linux中的每个用户（除了大管家用户，也就是超级用户root外。
    root因为太厉害，拥有所有权限，所以比较“任性”，跟普通用户不住在一起）都在home目录下有自己的一个私人目录。比如我的用户名是oscar，那么我的私人目录就是/home/oscar；如果另一个用户叫 john，那么他的私人目录就是/home/john；
- lib：表示“库”，包含被程序所调用的库文件。例如.so结尾的文件，在Windows下这样的库文件是以.dll结尾的；
- media：表示“媒体”。当一个可移动的外设（比如USB盘、SD卡、DVD、光盘等等）插入电脑时，Linux就可以让我们通过media的子目录来访问这些外设中的内容。
- mnt：表示“挂载”。有点类似media，但一般用于临时挂载一些装置；
- opt：表示“可选的应用软件包”，用于安装多数第三方软件和插件；
- root：超级用户 root 的家目录/主目录。一般用户的家目录是位于 /home 下，不过 root 用户是个例外。之前的课程我们也提到过，root 是整个系统的超级用户，拥有一切权限，初学者请慎用此用户模式；
- sbin：表示“系统二进制文件”。比起 bin 目录多了一个前缀 system，所以包含的是系统级的重要可执行程序；
- srv：表示“服务”。包含一些网络服务启动之后所需要取用的数据；
- tmp：表示“临时的”。普通用户和程序存放临时文件的地方；
- usr：表示“Unix操作系统软件资源”（也是个历史遗留的命名）。这个目录是最庞大的目录之一。有点类似Windows中的 C:\Windows和C:\Program Files这两个文件夹的集合。在这里面安装了大部分用户要调用的程序；
- var：表示“动态的，可变的”。通常包含程序的数据，比如一些log（日志）文件，记录电脑中发生了什么事。
```
#### 系统与硬件相关命令
```markdown
$ lspci -- 命令可以查看所有的 pci 设备，比如主板，声卡等
$ more /proc/cpuinfo -- 查看CPU信息
$ cat /proc/cpuinfo | grep “physical id”  | sort | uniq | wc -l -- 查看 CPU 的个数
$ cat /proc/cpuinfo |grep "processor" | wc -l -- 查看系统所有的逻辑CPU个数
$ more /proc/meminfo -- 查看内存的信息
$ fdisk -l -- 查看磁盘分区的信息
```
#### 系统服务管理工具
```markdown
$ systemctl status httpd.service -- 查看这个服务状态
$ systemctl start httpd.service -- 通过systemctl启动一个服务
$ systemctl stop httpd.service -- 停掉此服务
$ systemctl restart httpd.service -- 重启服务
$ systemctl try-restart httpd.service #只会在服务已经运行的状态下重启服务
$ systemctl reload httpd.service #重新加载配置文件
$ systemctl disable httpd.service -- 关闭服务
```
#### pwd和which
```markdown
pwd 命令用于显示当前所在目录；
which 命令用于获取命令的可执行文件的位置。
    pbj@pbj-Veriton-B430:~$ which which
    /usr/bin/which
    pbj@pbj-Veriton-B430:~$ which docker
    /usr/bin/docker
```
#### 目录相关的命令ls，cd和du
```markdown
ls 命令：列出文件和目录
    $ ls -a  //-a ：显示所有文件和目录，包括隐藏的。大写的参数-A，它的作用和小写的-a几乎一样，唯一不同就是-A不列出.和…这两个文件。
    $ ls -l // -l ：详细列表，列出一个显示文件和目录的详细信息列表；
    $ ls -h // -h：以 Ko，Mo，Go 的形式显示文件大小
    $ ls -t // -t：按文件最近一次修改时间排序
cd 命令：切换目录
    $ cd .. // Linux中，一个点表示当前目录，而两个点表示上一级目录：
du 命令：显示目录包含的文件大小
    $ du -h // -h：以 Ko，Mo，Go 的形式显示文件大小
    $ du -a // -a：显示文件和目录的大小
    $ du -s // -s：只显示总计大小
```
#### Linux 文件类型
```markdown
Linux 支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
1.普通文件（-）：用于存储信息和数据，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
2.目录文件（d，directory file）：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
3.符号链接文件（l，symbolic link）：保留了指向文件的地址而不是文件本身。
4.字符设备（c，char）：用来访问字符设备比如硬盘。
5.设备文件（b，block）：用来访问块设备比如硬盘、软盘。
6.管道文件(p,pipe):一种特殊类型的文件，用于进程之间的通信。
7.套接字(s,socket)：用于进程间的网络通信，也可以用于本机之间的非网络通信。
```
#### 文件操作
```markdown
cat 命令和 less 命令：显示文件内容
    $ cat 文件路径 // cat 命令：一次性显示文件的所有内容，cat -n 文件显示文件内容上加上行号
    $ less // less命令的好处是它会先读入文件开始的若干行，然后就停在那里，而这若干行的行数取决于终端屏幕的大小。
head 命令和 tail 命令：显示文件的开头和结尾
    $ head 文件路径 // head命令：显示文件开头，默认情况下，head会显示文件的头10行：也可以指定显示的行数，用-n这个参数：
    $ tail 文件路径 // tail命令：显示文件结尾，默认情况下，tail会显示文件的尾10行；也可以指定显示的行数，用-n这个参数：
    $ tail -f 文件路径 // tail命令还可以配合-f参数来实时追踪文件的更新：就会检查文件是否有追加内容，如果有，就显示新增内容：
    $ tail -f -s 4 文件路径 // 默认地，tail -f 会每过1秒检查一下文件是否有新内容。也可以指定间隔检查的秒数，用-s参数：
touch 命令和 mkdir 命令：创建文件和目录
    $ touch test.txt // touch 命令：创建一个空白文件，可以用touch命令同时创建多个文件：
    $ touch "new file.txt" // 要创建的文件的名字里有空格怎么办呢？很简单，加上双引号：
    $ mkdir myfile // mkdir：创建一个目录，还可以用-p参数来递归地创建目录结构。mkdir -p one/two/three
```
#### 文件的复制，移动，删除和链接
```markdown
cp 命令和 mv 命令：拷贝文件和移动文件
    $ cp test.txt test1.txt // cp 命令：拷贝文件或目录，不仅可以拷贝单个文件，还可以拷贝多个文件，也可以拷贝目录。
    $ cp -r myfile // 加上-r或者-R参数。拷贝的时候，目录中的所有内容（子目录和文件）都会被拷贝。
    $ mv test.txt /usr/local/ // mv 命令：移动文件
rm 命令：删除文件和目录
    $ rm -i test.txt // -i 参数：向用户确认是否删除
    $ rm -f test.txt // -f 参数：慎用，不会询问是否删除，强制删除
    $ rm -r myfile // -r 参数：递归地删除
ln 命令：创建链接
    事实上，Linux 下有两种链接类型：
        Physical link：物理链接或硬链接，一旦文件1和文件2之间有了硬链接，那么你修改文件1或文件2，其实修改的是相同的一块儿内容。只不过我们可以用两个文件名来获取到文件内容。
    $ ln file1 file2 // 创建了 file1 的一个硬链接 file2。
        Symbolic link：符号链接或软链接，像我们在Windows下的快捷方式的，其原理很相似。
    $ ln -s file1 file2 // 创建了 file1 的软链接 file2。
```
#### 用户管理
[centos创建新用户](https://blog.csdn.net/nieji3057/article/details/79421874)
```markdown
sudo // 切换到root用户
adduser 命令：添加新用户
    $ adduser pbj // 命令添加新用户
passwd 命令：修改密码
    $ passwd pbj // 修改用户密码
deluser：删除用户
    $ deluser pbj // 删除用户，终端不会提示你确认是否删除，而是直接删除了用户。
    单单用deluser命令，不加参数的话，只会删除用户，但是不会删除在/home目录中的用户家目录。
    $ deluser --remove-home pbj // 想要连此用户的家目录也一并删除，可以加上--remove-home这个参数
```
#### 群组的管理和文件权限管理
```markdown
addgroup：创建群组
delgroup 命令：删除群组
usermod 命令：修改用户账户
    -l：对用户重命名，但是/home目录中的用户家目录名不会改变，需要手动修改；
    -g：修改用户所在群组。此用户的家目录里的所有文件的所在群组会相应改变。
修改文件的所有者和群组
    chown 命令：改变文件的所有者  chown pbj text.xt  // -R 参数：递归设置子目录和子文件
    chgrp 命令：改变文件的群组 chgrp pbj text.txt
chmod 命令：修改访问权限
    d：表示“目录”。就是说这是一个目录；
    l：表示“链接”。就是说这是一个链接；
    r：表示“读”。就是说可以读这个文件；
    w：表示“写”。就是说可以写这个文件，也就是可以修改；
    x：表示“执行，运行”。就是说可以运行这个文件。
chmod 命令：修改文件的访问权限
    chmod 600 text.txt // 文件的访问权限被修改为rw-------，-R 参数：递归地修改访问权限
```
#### 如何查找特定的文件
```markdown
find 语法：find path [options] params  --在指定目录下查找文件（遍历你的实际硬盘，硬盘容量很大的话，那find命令会查找比较久。）
    find -name "text.md"  -- 在当前目录下递归查找text.md文件
    find / -name "text.md" -- 从根目录开始递归查找text.md文件
    find /var -size +10M -- 可以查找/var中大小超过10MB的文件（当然你要以root身份）
    find /var -size -50k -- 表示查找小于50K的文件：
    find ~ -name "aa*"  --去父目录下递归查找aa开头的文件
    find ~ -name "aa*"  --去父目录下递归查找aa开头的文件(不区分文件名大小写去查找文件)
    find -name "*.jpg" -atime -7 -- 使用-atime参数，根据文件的最近访问时间查找，表示7天之内，减号表示小于。
    sudo find . -name "new_file" -- -type参数来指定查找的文件类型
    man find: 更多关于find指令的使用说明
locate命令，快速查找
    locate命令不会对你实际的整个硬盘进行查找，而是在文件的数据库里查找记录。
    对于刚创建不久的文件，由于它们还没被收录进文件数据库，因此locate命令就找不到其索引，自然就不会返回任何结果。
    可以用updatedb命令强制系统立即更新文件数据库，但是updatedb命令只能由root用户执行。sudo updatedb
```
#### 数据文件处理
```markdown
grep 命令：筛选数据
    $ grep text file -- text代表要搜索的文本，file代表供搜索的文件。-i参数：忽略大小写，-n参数：显示行号，-v参数：只显示文本不在的行
        -r 参数：在所有子目录和子文件中查找，grep的高级用法：配合正则表达式。
sort 命令：为文件排序
    $ sort name.txt -- sort命令将name.txt文件中的行按照首字母的英文字典顺序进行了排列，并不区分大小写。
        -o参数：将排序后的内容写入新文件，-r参数：倒序排列；-R参数：随机排序；-n参数：对数字排序；
wc 命令：文件的统计
    $ wc name.txt -- 返回分别是行数、单词数、字节数。-l参数：统计行数，-w参数：统计单词数，-c参数：统计字节数；-m参数：统计字符数
uniq 命令：删除文件中的重复内容
    $ uniq repeat.txt -- 把处理后的内容显示出来，-c参数：统计重复的行数；-d参数：只显示重复行的值
    $ uniq repeat.txt unique.txt -- 将处理后的内容储存到一个新文件中
cut 命令：剪切文件的一部分内容
    $ cut -c 2-4 name.txt -- name.txt的每一行只保留第2至第4个字符。-c参数：根据字符数来剪切
```
#### 流和输出重定向
```markdown
“> 和 >>”：重定向到文件
    $ cut -d , -f 1 notes.csv -- 文件每一行用,分割，剪切第一部分的内容输出
    $ cut -d , -f 3 notes.csv -- 文件每一行用,分割，剪切第三部分的内容输出
    $ cut -d , -f 1,3 notes.csv -- 文件每一行用,分割，剪切第一、三部分的内容输出
    $ cut -d , -f 2- notes.csv -- 文件每一行用,分割，剪切第二部分直到最后的内容输出
    $ cut -d , -f 1 notes.csv > students.txt -- 内容重定向到students.txt文件
    $ cut -d , -f 1 notes.csv >> students.txt -- 内容重定向到students.txt文件末尾
“2>，2>>，2>&1”：重定向错误输出
    $ cat not_exist_file.csv > results.txt 2> errors.log -- 假如这个文件确实存在，将其内容写入results.txt文件中否则错误信息写入errors.log文件中
        类似的，2>> 符号用于将标准错误输出重定向到文件末尾。
    $ cat not_exist_file.csv > results.txt 2>&1 -- 将这个命令的所有输出（标准输出和标准错误输出）都重定向到results.txt文件中。
    $ cat not_exist_file.csv >> results.txt 2>&1 -- 将这个命令的所有输出（标准输出和标准错误输出）都重定向到results.txt文件末尾。
```
#### 输入重定向和管道
```markdown
<，<<：从文件或键盘读取
    $ cat < notes.csv -- 将命令的输入重定向为文件内容。
    $ sort -n << END -- 将键盘的输入重定向为某个命令的输入，sort -n的作用是将数值按照从小到大进行排列，输入END来结束输入
    $ wc -m << END -- wc命令用于统计字符等，配合-m参数可以统计字符数。
| ：管道（将两个命令连成管道，简单地说就是将一个命令的输出作为另一个命令的输入）
    $ cut -d , -f 1 notes.csv | sort -- 按学生名字排序
    $ cut -d , -f 1 notes.csv | sort > sorted_names.txt 
    $ du | sort -nr | head -- 根据大小排序目录
    $ sudo grep log -Ir /var/log | cut -d : -f 1 | sort | uniq -- 列出包含关键字的文件
```
#### 监视系统活动和查看进程
```markdown
w 命令：都有谁，在做什么？
    $ w
    $ date
    $ uptime
    $ tload
    $ who
ps 命令和 top 命令：列出运行的进程
    $ ps
    $ ps -ef -- 列出所有进程
    $ ps -efH -- 以乔木状列出所有进程
    $ ps -u 用户名 -- 列出此用户运行的进程
    $ ps -aux | less -- 通过 CPU 和内存使用来过滤进程
    $ ps -aux --sort -pcpu | less -- 根据 CPU 使用率来降序排列
    $ ps -aux --sort -pmem | less -- 根据内存使用率来降序排列
    $ ps -aux --sort -pcpu,+pmem | head -- 将CPU和内存参数合并到一起，并通过管道显示前10个结果
pstree 命令：以树形结构显示进程，ps -axjf 和 pstree 命令的效果比较类似，都能以树形结构显示进程。
```
#### 进程操作和系统重启
```markdown
top：进程的动态列表
Ctrl + C 和 kill 命令：停止进程
    $ kill pid -- 结束一个进程
    $ kill -9 7291 -- kill -9 来立即强制结束进程
    $ killall find -- 结束多个进程
halt 命令和 reboot 命令：停止和重启系统
    $ sudo halt：关闭系统
    $ sudo reboot：重启系统
    $ poweroff -- 立即关机
```
#### 前后台进程，灵活切换
```markdown
& 符号和 nohup 命令：后台运行进程
    $ cp emacs-26.2.tar.gz emacs-26.2-copy.tar.gz & -- 命令最后加了&符号，运行时此进程就成为了后台进程
nohup 命令：使进程与终端分离
    $ nohup cp node-v10.15.3.tar.gz node-v10.15.3-copy.tar.gz -- 使用nohup命令后，输出会被默认地追加写入到一个叫nohup.out的文件里。
    $ nohup cp node-v10.15.3.tar.gz node-v10.15.3-copy.tar.gz &
Ctrl + Z，jobs，bg 和 fg 命令：控制进程的前后台切换
    $ Ctrl + Z：转到后台，并暂停运行
    $ bg 命令：使进程转到后台
    $ jobs 命令：显示后台进程状态
    $ fg 命令：使进程转到前台
```
#### 定时和延时执行
```markdown
date 命令：调节时间
    $ date "+%H" -- 定制输出时间的小时
    $ date "+%H:%M:%S"  
    $ date "+%H时%M分%S秒"
at 命令：延时执行一个程序
    $ sudo apt install at
    $ at 22:10 回车输入要定时执行的命令，可以输入touch file.txt，表示想要在22点10分创建一个文件，名叫file.txt。
    $ at 22:10 tomorrow -- 在明天的 22 点 10 分执行
    $ at 22:10 12/10/19 -- 要在 2019 年 12 月 10 日的 22 点 10 分执行
    $ at now +10 minutes -- 在指定间隔之后执行程序，十分钟之后执行
    $ atq 和 atrm 命令：列出和删除正在等待执行的 at 任务
sleep 命令：休息一会
crontab 命令：定时执行程序
    希望每天的22点10分都在家目录下创建file.txt文件。可以在 crontab 文件里写入：10 22 * * * touch ~/file.txt
```
#### 压缩文件和解压
```markdown
tar命令：将多个文件归档(tar可以同时压缩多个文件。)
    $ tar -cvf sorting.tar sorting/ -- -cvf：创建一个tar归档
    $ tar -cvf archive.tar file1.txt file2.txt file3.txt -- 把file1.txt，file2.txt，file3.txt 归档为 archive.tar
    $ tar -tf sorting.tar -- -tf：显示归档里的内容，并不解开归档
    $ tar -rvf archive.tar file_extra.txt -- -rvf：追加文件到归档
    $ tar -xvf sorting.tar -- -xvf：解开归档
    $ tar -zcvf sorting.tar.gz sorting -- 用tar命令同时归档和压缩，-zcvf：归档，然后用gzip来压缩归档
    $ tar -zxvf sorting.tar.gz -- 用tar命令同时归档和解压缩
    $ tar -jcvf sorting.tar.bz2 sorting/ -- -jcvf：归档，然后用bzip2来压缩归档
    $ tar -jxvf sorting.tar.bz2 -- 解压
gzip和bzip2命令：压缩归档(gzip和bzip2不能同时压缩多个文件，一次只能压缩一个文件。)
    $ gzip sorting.tar -- 将sorting.tar文件改变为sorting.tar.gz压缩文件
    $ bzip2 sorting.tar -- 将sorting.tar压缩为sorting.tar.bz2压缩文件
    $ gunzip sorting.tar.gz -- 解压
    $ bunzip2 sorting.tar.bz2 -- 解压
    zcat，zmore，zless 命令就可以显示用 gzip 命令压缩的文件的内容
zip/unzip和rar/unrar 命令：压缩/解压zip和rar文件
    $ sudo apt install unzip     # 这是在 Debian 一族中的安装方式 
    $ sudo apt install zip      # 这是在 Debian 一族中的安装方式
    $ unzip archive.zip -- 解压 .zip 格式的压缩文件
    $ zip -r sorting.zip sorting/ -- 压缩一下我们的 sorting 目录
    $ sudo apt install unrar     # 这是在 Debian 一族中的安装方式
    $ sudo apt install rar     # 这是在 Debian 一族中的安装方式
    $ unrar e archive.rar -- 解压 .rar 格式的压缩文件
    $ rar a sorting.rar sorting/ -- 压缩一下我们的 sorting 目录
```
#### 文件传输和同步
```markdown
wget ：下载文件
scp ：网间拷贝
ftp & sftp ：传输文件
rsync ：同步备份
```

## Linux Shell脚本总结
[参考书：Linux命令行与shell脚本编程大全](https://www.baidu.com)
[随笔分类 - Shell](https://www.cnblogs.com/surpassme/category/1257268.html)
#### 查看系统中所有可用的Shell和用户Shell
```markdown
$ cat /etc/shells
    # /etc/shells: valid login shells
    /bin/sh
    /bin/bash
    /bin/rbash
    /bin/dash
$ grep root /etc/passwd # 用户登录到Linux系统时，由/etc/passwd文件决定用户将要使用哪种shell。
    pbj:x:1000:1000:pbj,,,:/home/pbj:/bin/bash
$ echo $SHELL
    /bin/bash
```
#### Shell脚本
```markdown
Shell脚本是利用Shell的功能所写的一个程序，是纯文本格式，将一些Shell的语法与指令写在里面，利用正则表达式、命令管道以及数据流重定向等功能以实现我们需要的功能。
Shell脚本一般由以下几部分组成：
    - Shell关键字--例如：if...else,for do...done
    - Shell命令-- 例如: export,echo,exit,pwd,return
    - Linux命令-- 例如： date,rm,mkdir
    - 文本处理功能--例如：awk,cut,sed,grep
    - 函数--
    - 控制流语句--例如if..then...else或执行重复操作的Shell循环
```
#### 编写第一个Shell脚本
```markdown
$ vi my_first_script文件输入
#!/bin/bash
# my first script

ls -l .*
保存文件
$ chomd 755 my_first_script # 修改文件权限  cjomd u+x my_first_script
$ ./my_first_script # 运行脚本
```
#### 理解shell的内建命令
```markdown
外部命令，有时候也被称为文件系统命令，是存在于bash shell之外的程序。它们并不是shell程序的一部分。
    外部命令程序通常位于/bin、/usr/bin、/sbin或/usr/sbin中。ps就是一个外部命令。你可以使用which和type命令找到它。
    当外部命令执行时，会创建出一个子进程。这种操作被称为衍生（forking）。
    当进程必须执行衍生操作时，它需要花费时间和精力来设置新子进程的环境。所以说，外部命令多少还是有代价的。
内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和shell编译成了一体，作为shell工具的组成部分存在。不需要借助外部程序文件来运行。
    因为既不需要通过衍生出子进程来执行，也不需要打开程序文件，内建命令的执行速度要更快，效率也更高。
    要注意，有些命令有多种实现。例如echo和pwd既有内建命令也有外部命令。两种实现略有不同。要查看命令的不同实现，使用type命令的-a选项。
$ type -a pwd
$ type -a ps
```
#### Linux环境变量
```markdown
bash shell用一个叫作环境变量（environment variable）的特性来存储有关shell会话和工作环境的信息（这也是它们被称作环境变量的原因）。
    这项特性允许你在内存中存储数据，以便程序或shell中运行的脚本能够轻松访问到它们。这也是存储持久数据的一种简便方法。 
    在bash shell中，环境变量分为两类：
        - 全局变量（全局环境变量对于shell会话和所有生成的子shell都是可见的。）
        - 局部变量（局部变量则只对创建它们的shell可见。）
    $ printenv -- 要查看全局变量，可以使用env或printenv命令。要显示个别环境变量的值，可以使用printenv命令，但是不要用env命令。
    $ echo $HOME
    $ set -- set命令会显示为某个特定进程设置的所有环境变量，包括局部变量、全局变量以及用户定义变量。
设置用户定义变量
    - 设置局部用户定义变量(所有的环境变量名均使用大写字母，这是bash shell的标准惯例。)
        一旦启动了bash shell（或者执行一个shell脚本），就能创建在这个shell进程内可见的局部变量了。可以通过等号给环境变量赋值，值可以是数值或字符串。
        **变量名、等号和值之间没有空格**
        $ my_variable=Hello # 如果要给变量赋一个含有空格的字符串值，必须用单引号来界定字符串的首和尾。
        $ echo $my_variable
    - 设置全局环境变量（子shell甚至无法使用export命令改变父shell中全局环境变量的值。）
        $ export my_variable # 通过export命令来完成局部环境变量导出到全局环境中
    - 删除环境变量
        $ nuset my_variable
设置PATH环境变量
    PATH环境变量定义了用于进行命令和程序查找的目录。 $ echo $PATH
定位系统环境变量
    /etc/profile文件是bash shell默认的的主启动文件。
```
#### vi&vim编辑器
```markdown
vi编辑器是Unix系统最初的编辑器。它使用控制台图形模式来模拟文本编辑窗口，允许查看文件中的行、在文件中移动、插入、编辑和替换文本。
$ alias vi # 检查vim软件包
$ which vim
$ sudo apt-get install vim # 在Ubuntu发行版中安装基础版的vim包
vim中有用来移动光标的命令
     h：左移一个字符。
     j：下移一行（文本中的下一行）。
     k：上移一行（文本中的上一行）。
     l：右移一个字符。
     PageDown（或Ctrl+F）：下翻一屏。
     PageUp（或Ctrl+B）：上翻一屏。
     G：移到缓冲区的最后一行。
     num G：移动到缓冲区中的第num行。
     gg：移到缓冲区的第一行。
在命令行模式下有几个命令可以将缓冲区的数据保存到文件中并退出vim。
     q：如果未修改缓冲区数据，退出。
     q!：取消所有对缓冲区数据的修改并退出。
     w filename：将文件保存到另一个文件中。
     wq：将缓冲区数据保存到文件中并退出。
编辑数据:在插入模式下，你可以向缓冲区插入数据。
    x 删除当前光标所在位置的字符
    dd 删除当前光标所在行
    dw 删除当前光标所在位置的单词
    d$ 删除当前光标所在位置至行尾的内容
    J 删除当前光标所在行行尾的换行符（拼接行）
    u 撤销前一编辑命令
    a 在当前光标后追加数据
    A 在当前光标所在行行尾追加数据
    r char 用char替换当前光标所在位置的单个字符
    R text 用text覆盖当前光标所在位置的数据，直到按下ESC键
查找和替换:使用vim查找命令来轻松查找缓冲区中的数据
    1、命令模式下输入“/字符串”，例如“/bug”。
    2、如果查找下一个，按“n”即可。
     :s/old/new/g：一行命令替换所有old。 
     :n,ms/old/new/g：替换行号n和m之间所有old。 
     :%s/old/new/g：替换整个文件中的所有old。 
     :%s/old/new/gc：替换整个文件中的所有old，但在每次出现时提示。
```
#### echo命令显示消息
```markdown
可以通过echo命令显示消息
echo命令可用单引号或双引号来划定文本字符串。如果在字符串中用到了它们，需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。
$ cat test1 
#!/bin/bash 
# This script displays the date and who's logged on 
echo The time and date are: 
date 
echo "Let's see who's logged into the system:" 
who
如果想把文本字符串和命令输出显示在同一行中可以用echo语句的-n参数。只要将第一个echo语句改成这样就行：echo -n "The time and date are:"
```
#### shell命令使用变量
```markdown
$ set # 查看当前环境变量列表
在环境变量名称之前加上美元符（$）来使用这些环境变量。
$ vi varecho 
‘
#！bin/bash
# display user information from the system 将$USER系统变量放置到双引号中，shell命令依然可以解析
echo "User info for userid: $USER"
echo UID: $UID
echo HOME: $HOME
echo JAVA_HOME: $JAVA_HOME
’
chomd u+x varecho
要显示美元符，你必须在它前面放置一个反斜线。
除了环境变量，shell脚本还允许在脚本中定义和使用自己的变量。
定义变量允许临时存储数据并在整个脚本中使用，从而使shell脚本看起来更像一个真正的计算机程序。
命令替换：反引号字符（`），$()格式
$ cat test5 
#!/bin/bash 
testing=$(date) 
echo "The date and time are: " $testing 
$
```
#### 结构化命令if-then
```markdown
if-then语句
    格式：
        if command  # command命令的退出状态码是0，则then部分的命令就会被执行。其他值则不会执行。
        then
            commands  # then部分可以使用多条命令
        fi
    简单实例1：
    $ vi if-then-test.sh
    #!/bin/bash
    # testing the if then statement
    if pwd   # if行命令不能执行时还在命令出错时，then部分命令不能执行
    then 
        echo it worked
    fi
    $ chomd u+x if-then-test.sh
    $ ./if-then-test.sh
    简单实例2：
    $ vi if-thens-test.sh
    #!/bin/bash
    # testing multiple commands in the then section
    #
    testuser=pbj
    #
    if grep $testuser /etc/passwd
    then
        echo This is my first command.
        echo This is my second command.
        echo I can ecen put in the commands besides echo:
        ls -a /home/$testuser/.b*
    fi
    $ chomd u+x if-thens-test.sh
    $ ./if-thens-test.sh
if-then-else语句，可以使用嵌套的if-then语句。
    语句格式：
        if command  # 当if语句中的命令返回退出状态码0时，then部分中的命令会被执行
        then
            commands
        else       # 当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。
            commands
        fi
test命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。
    这样if-then语句就与其他编程语言中的if-then语句以类似的方式工作了。
    test命令的格式：
        test condition
    当用在if-then语句中时，test命令看起来是这样的。
        if test condition  # 如果不写test命令的condition部分，它会以非零的退出状态码退出，并执行else语句块。
        then
            commands
        else 
            commands
        fi
    test命令实例：
        $ cat test6.sh
        #!/bin/bash 
        # Testing the test command 
        # 
        my_variable="Full" 
        # 
        if test $my_variable 
        then 
         echo "The $my_variable expression returns a True" 
        # 
        else 
         echo "The $my_variable expression returns a False" 
        fi 
        $ 
        $ ./test6.sh
        The Full expression returns a True 
        $
case语句：case命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的，那么shell会执行为该模式指定的命令。
    case简单实例：
        $ cat test26.sh
        #!/bin/bash 
        # using the case command 
        # 
        case $USER in 
        rich | barbara) 
         echo "Welcome, $USER" 
         echo "Please enjoy your visit";; 
        testing) 
         echo "Special testing account";; 
        jessica) 
         echo "Do not forget to log off when you're done";; 
        *) 
         echo "Sorry, you are not allowed here";; 
        esac 
        $ 
        $ ./test26.sh
        Welcome, rich 
        Please enjoy your visit 
        $
```
#### 结构化命令for&while&until
```markdown
for命令
    bash shell中for命令的基本格式：  
    for var in list # 在list参数中，需要提供迭代中要用到的一系列值。在每次迭代中，
        # 变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个值，以此类推，直到列表中的所有值都过一遍。
    do 
        commands
    done
    简单实例：
        $ cat test1 
        #!/bin/bash 
        # basic for command 
        for test in Alabama Alaska Arizona Arkansas California Colorado 
        do 
         echo The next state is $test 
        done 
        $ ./test1 
        The next state is Alabama 
        The next state is Alaska 
        The next state is Arizona 
        The next state is Arkansas 
        The next state is California 
        The next state is Colorado 
        $
    $test变量的值会在shell脚本的剩余部分一直保持有效。它会一直保持最后一次迭代的值（除非你修改了它）。
    可以使用“”为list中的元素划分开来，也可以从变量、命令值中读取list。
    在bash shell程序中使用C语言风格的for命令。
while命令
    while命令的格式是：
        while test command 
        do 
            other commands 
        done
    while命令简单实例：
        $ cat test11 
        #!/bin/bash 
        # testing a multicommand while loop 
        var1=10 
        while echo $var1 
         [ $var1 -ge 0 ] 
        do 
         echo "This is inside the loop" 
         var1=$[ $var1 - 1 ] 
        done 
        $ ./test11
until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，
    bash shell才会执行循环中列出的命令。一旦测试命令返回了退出状态码0，循环就结束了。
    until命令的格式如下：
        until test commands
        do
            other commands
        done
    until命令简单实例：
        $ cat test12 
        #!/bin/bash 
        # using the until command 
        var1=100 
        until [ $var1 -eq 0 ] 
        do 
         echo $var1 
         var1=$[ $var1 - 25 ] 
        done 
        $ ./test12
循环控制：break命令和continue命令
处理循环的输出：在shell脚本中，可以对循环的输出使用管道或进行重定向。通过在done命令之后添加一个处理命令来实现。
    简单实例：
        $ cat test23 
        #!/bin/bash
        # redirecting the for output to a file 
        for (( a = 1; a < 10; a++ )) 
        do 
         echo "The number is $a" 
        done > test23.txt   # shell创建了文件test23.txt并将for命令的输出重定向到这个文件
        echo "The command is finished."  # shell在for命令之后正常显示了echo语句
        $ ./test23
```
#### 处理医患输入
```markdown
如何在你的bash shell脚本运用这些方法来从脚本用户处获得数据。
1.命令行参数
    $ ./my_script 10 30  # 脚本会通过特殊的变量来处理命令行参数。
    bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数。
    可以在shell脚本中像使用其他变量一样使用$1变量。shell脚本会自动将命令行参数的值分配给变量，不需要你作任何处理。
    如果需要输入更多的命令行参数，则每个参数都必须用空格分开。
    $ cat test3.sh
    #!/bin/bash 
    # testing string parameters 
    # 
    echo Hello $1, glad to meet you. 
    $ 
    $ ./test3.sh Rich
    Hello Rich, glad to meet you. 
    每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，必须要用引号（单引号或双引号均可）。
    如果脚本需要的命令行参数不止9个，仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，必须在变量数字周围加上花括号，比如${10}。
    可以用$0参数获取shell在命令行启动的脚本名。
    当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。
2.特殊参数变量 (在bash shell中有些特殊变量，它们会记录命令行参数。)
    2.1.特殊变量$#含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量一样。
    $ cat test8.sh
    #!/bin/bash 
    # getting the number of parameters 
    # 
    echo There were $# parameters supplied. 
    $ 
    $ ./test8.sh
    There were 0 parameters supplied.
    if-then语句用-ne测试命令行参数数量。如果参数数量不对，会显示一条错误消息告知脚本的正确用法。
    2.2.$*和$@变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数。
        $*变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。
        $@变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样就能够遍历所有的参数值，得到每个参数。
    $ cat test11.sh
    #!/bin/bash 
    # testing $* and $@ 
    # 
    echo 
    echo "Using the \$* method: $*" 
    echo 
    echo "Using the \$@ method: $@" 
    $ 
    $ ./test11.sh rich barbara katie jessica
    2.3.bash shell的shift命令能够用来操作命令行参数。跟字面上的意思一样，shift命令会根据它们的相对位置来移动命令行参数。
    在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除（注意，变量$0的值，也就是程序名，不会改变）。
    $ cat test13.sh
    #!/bin/bash 
    # demonstrating the shift command
    echo 
    count=1 
    while [ -n "$1" ] 
    do 
     echo "Parameter #$count = $1" 
     count=$[ $count + 1 ] 
     shift 
    done 
    $ 
    $ ./test13.sh rich barbara katie jessica
3.获取用户输入（bash shell为此提供了read命令。）
    read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。
    $ cat test21.sh 
    #!/bin/bash 
    # testing the read command 
    # 
    echo -n "Enter your name: " 
    read name 
    echo "Hello $name, welcome to my program. " 
    # 
    $ ./test21.sh
    可以用-t选项来指定一个计时器。-t选项指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。
    $ cat test25.sh
    #!/bin/bash 
    # timing the data entry 
    # 
    if read -t 5 -p "Please enter your name: " name 
    then 
     echo "Hello $name, welcome to my script" 
    else 
     echo 
     echo "Sorry, too slow! " 
    fi 
    $ 
    $ ./test25.sh
```
#### 控制脚本
```markdown
控制方法包括向脚本发送信号、修改脚本的优先级以及在脚本运行时切换到运行模式。

```
#### 创建函数
```markdown
创建函数：第一种格式采用关键字function，后跟分配给该代码块的函数名。
    function name {   # name属性定义了赋予函数的唯一名称。脚本中定义的每个函数都必须有一个唯一的名称。
     commands   # commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。
    }
使用函数：只需要像其他shell命令一样，在行中指定函数名就行了。
    #!/bin/bash 
    # using a function in a script 
    function func1 { 
     echo "This is an example of a function" 
    } 
    count=1 
    while [ $count -le 5 ] 
    do 
     func1 
     count=$[ $count + 1 ] 
    done 
    echo "This is the end of the loop" 
    func1 
    echo "Now this is the end of the script" 
    $ 
    $ ./test1
函数返回值：
    默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码。
    函数的退出状态码是1，这是因为函数中的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行。
    bash shell使用return命令来退出函数并返回特定的退出状态码。return命令允许指定一个整数值来定义函数的退出状态码，从而设定函数退出状态码。
    $ cat test5 
    #!/bin/bash 
    # using the return command in a function 
    function dbl { 
     read -p "Enter a value: " value 
     echo "doubling the value" 
     return $[ $value * 2 ] 
    } 
    dbl 
    echo "The new value is $?" 
    $
创建函数库：bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。
    $ cat myfuncs 
    # my script functions 
    function addem { 
     echo $[ $1 + $2 ] 
    } 
    function multem { 
     echo $[ $1 * $2 ] 
    } 
    function divem { 
     if [ $2 -ne 0 ] 
     then 
     echo $[ $1 / $2 ] 
     else 
     echo -1 
     fi 
    } 
    $
    可以用source命令来在shell脚本中运行库文件脚本。这样脚本就可以使用库中的函数了。
    source命令有个快捷的别名，称作点操作符（dot operator）。要在shell脚本中运行myfuncs库文件，只需添加下面这行：../myfuncs
```
#### sed和gawk
```markdown
sed编辑器被称作流编辑器（stream editor），和普通的交互式文本编辑器恰好相反。
    在交互式文本编辑器中（比如vim），你可以用键盘命令来交互式地插入、删除或替换数据中的文本。
    流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。
    sed命令的格式如下。
    sed options script file
    $ sed 's/dog/cat/' data1.txt 等同于  $ cat data1.txt
    $ sed -e 's/brown/green/; s/dog/cat/' data1.txt  # 在sed命令行上执行多个命令时，只要用-e选项
gawk程序是Unix中的原始awk程序的GNU版本。提供了一种编程语言而不只是编辑器命令。
    在gawk编程语言中，你可以做下面的事情：
         定义变量来保存数据；
         使用算术和字符串操作符来处理数据；
         使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑；
         通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。
    gawk程序的基本格式如下：
        gawk options program file
```
#### 
#### 

