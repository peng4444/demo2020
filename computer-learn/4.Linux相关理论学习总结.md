# Linux相关理论学习总结
[参考资料：极客时间趣谈Linux操作系统](https://www.baidu.com)

[TOC]


##
### Linux学习过程
![image-20201121143610963](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121143618.png)
```markdown
熟练使用Linux命令行、使用Linux进行程序设计、了解Linux内核机制、阅读Linux内核代码、实验定制Linux组件，以及最后落到生产实践上。
    《鸟哥的Linux私房菜》
    先读《UNIX 环境高级编程》，后读的《Unix/Linux编程实践教程》
    《庖丁解牛Linux内核分析》
```
### 双击鼠标打开QQ
![image-20201121145051750](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121145051.png)
```markdown
“双击鼠标打开QQ”这样一个简单的操作，它几乎涵盖了操作系统的所有功能。
1.“双击 QQ”这个过程，都需要用到哪些硬件？
    - 鼠标和键盘是计算机的输入设备。输入设备驱动
    - 屏幕，也就是显示器，是计算机的输出设备。显卡，显卡驱动，在操作系统中称为输出设备驱动。
2.文件管理子系统（File Management Subsystem），程序（Program），进程（Process），系统调用（System Call）
    进程管理子系统（Process Management Subsystem），内存管理子系统（Memory Management Subsystem），
```
### 操作系统内核体系结构图
![image-20201121145248073](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121145248.png)
### 系统调用
```markdown
进程管理：
    在Linux里，要创建一个新的进程，需要一个老的进程调用fork来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
    当父进程调用fork创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。
    对于fork系统调用的返回值，如果当前进程是子进程，就返回0；如果当前进程是父进程，就返回子进程的进程号。
内存管理：
    在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。
    对于进程的内存空间来讲，放程序代码的这部分，我们称为代码段（Code Segment）。
    对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为数据段（Data Segment）。
    其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；
    也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。
文件管理：
信号处理：
进程间通信：
网络通信：
```
### 一个进程从代码到二进制到运行时的一个过程（创建进程）
![image-20201123134725509](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201123134732.png)
```markdown
我们首先通过图右边的文件编译过程，生成so文件和可执行文件，放在硬盘上。
上图左边的用户态的进程 A 执行 fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec 系列系统调用。
这个系统调用会通过 load_elf_binary 方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。
```
### 如何创建线程
![image-20201123135317002](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201123135317.png)
```markdown
一个普通线程的创建和运行过程
    - 声明线程函数
    - 声明线程对象
    - 设置线程属性
    - 创建线程
    - 销毁线程属性
    - 等待线程结束
    - 主线程结束
线程的数据
    - 第一类是线程栈上的本地数据，比如函数执行过程中的局部变量。
    - 第二类数据就是在整个进程里共享的全局数据。例如全局变量，虽然在不同进程中是隔离的，但是在一个进程中是共享的。
    - 这就是第三类数据，线程私有数据（Thread Specific Data）
如何对线程数据进行保护
    - 线程加锁（互斥锁）
```
### 用户态和内核态，函数栈的工作模式
```markdown
在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？
用户态函数栈
    在用户态中，程序的执行往往是一个函数调用另一个函数。函数调用都是通过栈来进行的。
内核态函数栈
    Linux给每个task都分配了内核栈。
    当系统调用从用户态到内核态的时候，首先要做的第一件事情，就是将用户态运行过程中的CPU上下文保存起来，
    其实主要就是保存在这个结构的寄存器变量里。这样当从内核系统调用返回的时候，才能让进程在刚才的地方接着运行下去。
    通过task_struct找内核栈，就能够轻松得到内核栈和内核寄存器。
    通过内核栈找task_struct
在Linux里面，进程大概可以分成两种。
    - 一种称为实时进程，也就是需要尽快执行返回结果的那种。
    - 另一种是普通进程，大部分的进程其实都是这种。
调度策略与调度类
    - 实时调度策略
        对于调度策略，其中 SCHED_FIFO、SCHED_RR、SCHED_DEADLINE 是实时进程的调度策略。
        对于普通进程的调度策略有，SCHED_NORMAL、SCHED_BATCH、SCHED_IDLE。
    - 完全公平调度算法
主动调度是如何发生的？       
    - 主动调度的过程，也即一个运行中的进程主动调用__schedule让出CPU。
    在__schedule里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。
    而上下文切换又分用户态进程空间的切换和内核态的切换。
    - 上下文切换主要干两件事情，一是切换进程空间，也即虚拟内存；二是切换寄存器和CPU上下文。
抢占式调度是如何发生的？
    - 最常见的现象就是一个进程执行时间太长了，是时候切换到另一个进程了。
    - 另外一个可能抢占的场景是当一个进程被唤醒的时候。
```



[全方位剖析Linux操作系统](https://www.cnblogs.com/cxuanBlog/p/13789900.html)
[后端程序员必备的 Linux 基础知识+常见命令](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247493578&idx=2&sn=ae265b5b05204fcb949fee41fd2d7d13&chksm=fc461a39cb31932fcd084bf566f9d2ea9111a7da56cc2a408eac8145e8d5a64f5005e1e2e28b&mpshare=1&scene=23&srcid=0901oUWt9SKi6zFY7iH7oC0d&sharer_sharetime=1598924671509&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
[linux服务器负载问题排查](https://www.cnblogs.com/chenfangzhi/p/9981614.html)
[Keepalived 原理与实战](https://www.cnblogs.com/christopherchan/p/12953230.html)
[linux系统下扩展磁盘空间](https://blog.csdn.net/weixin_41229271/article/details/80476648)
[LVM : 扩展文件系统的容量](https://www.cnblogs.com/sparkdev/p/10142629.html)
[如何构建“高性能”“大小无限”（磁盘）队列？](https://www.cnblogs.com/yougewe/p/10988194.html)

### Linux I/O
#### 1.1 五种I/O模型
[带你真正的搞懂，Linux的5种I/O模型](https://www.toutiao.com/a6619988112300835331/)
```markdown
Unix 有五种 I/O 模型：
    阻塞式I/O（blocking IO）: 应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。
    非阻塞式I/O（nonblocking IO）:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知I/O是否完成，这种方式称为轮询（polling）。
    I/O复用（IO multiplexing）（select和poll）:使用select或者poll等待数据，并且可以等待多个套接字中的任何一个变为可读。
        这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。
    信号驱动式I/O（SIGIO）:应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。
    异步I/O（asynchronous IO）（AIO:应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。
```
#### 1.2 I/O复用
```markdown
I/O复用是通过一种机制，一个进程可以监听多个文件描述符，一旦某个fd就绪（一般是读就绪或写就绪），就通知程序进行相应的操作。
同步I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。
异步I/O：不会阻塞。
阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。
非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
```
#### 1.3 IO多路复用模型select、poll和epoll函数的区别？【5+】
[IO多路复用中select、poll、epoll之间的区别？](https://blog.csdn.net/weixin_44359909/article/details/107795454)
```markdown
目前Linux上主要的I/O多路复用模型有三种，select、poll、epoll，它们本质上都是同步I/O，即要求读写事件就绪后自己负责进行读写，这会导致请求进程阻塞，直到I/O操作完成。
select、poll、eopll是操作系统处理网络上传输过来的数据的不同实现，数据从经过网线流入网卡，网卡中的驱动程序会向CPU发出中断信号，
    在交互系统中，中断信号的优先级是很高的，CPU立刻去处理这个中断信息，CPU通过终端表找到相应的处理函数：
 select函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，或者超时，函数返回，当select函数返回后，就可以遍历描述符，找到就绪的描述符。
    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制。
 poll没有最大限制（但是数量过大后性能也是会下降）。和select函数一样，poll返回后，需要轮询来获取就绪的描述符。
 epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的
    情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。
 epoll通过监控注册的多个描述字，来进行I/O事件的分发处理。不同poll的是，epoll不仅提供了默认的level-triggered（条件触发）机制，还提供了性能更为强劲的edge triggered（边缘触发）机制
```
#### 1.4 BIO、NIO、AIO有什么区别？【3+】
```markdown
BIO：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。(InputStream、OutputStream、Reader、Writer)
NIO：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。
    (Channels、Buffers、Selectors)
AIO：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。
BIO 是一个连接一个线程。,NIO是一个请求一个线程。,AIO是一个有效请求一个线程。
BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
IO多路复用：调用系统级别的select、poll、epoll
```
#### [说了这么多次 I/O，但你知道它的原理么](https://www.cnblogs.com/cxuanBlog/p/13032486.html)
### Linux常用命令【3+】
#### Linux基础命令
```markdown
文件管理：ls、cd、touch创建普通文件、rm删除、mkdir新建目录、mv移动、cp拷贝、chmod修改权限
    通过df命令可以查看磁盘的剩余空间： df -h -h表示按单位格式化输出。-d指定了递归深度为1层，
    可以使用iostat来查看系统的磁盘I/O状况：iostat -d -k -d表示查看磁盘使用状况，-k表示以KB为单位显示。
    通过vmstat命令，可以查看到Swap I/O的情况： vmstat swap列的si表示每秒从磁盘交换到内存的数据量，单位是KB/s，so表示每秒从内存交换到磁盘的数据量，单位也是KB/s。
进程管理：ps显示进程信息、kill杀死进程
系统管理：top、free显示系统运行信息、vmstat输出各资源使用情况
    w、top、uptime这三个命令都可以用来查看系统的load值，下面演示一下使用uptime命令查看系统的load： uptime
    通过free命令能够查看到系统的内存使用情况，加上-m参数表示以MB为单位：free -m
    linux查看进程所占内存命令: 使用 ps -ef | grep mysql 查看mysql这个进程的id
                            使用 top -p 进程id  查看到进程的CUP和内存的占用率
                            可直接使用ps命令查看： ps -aux | grep kafka 
网络通讯：ping测试网络连通性、netstat显示网络相关信息
Linux 命令，查看文件前十行，后十行 head,tail
端口被占用: lsof -i 端口号
           netstat -ntulp | grep 端口号
统计文件有多少行：
    wc [选项] 文件…
      - c 统计字节数。
      - l 统计行数。
      - w 统计字数。
```
#### Linux中常见的网络命令
[面试官问我Linux下常见网络命令](https://mp.weixin.qq.com/s?__biz=MzIwOTE2MzU4NA==&mid=2247486142&idx=1&sn=847511b9f15751f35a6bbab631a612a3&chksm=97794e91a00ec78702acc82c35828011f0f98fff3c1b55741372b73c20e26a1f1e6dde70ae5f&mpshare=1&scene=23&srcid=0924Z8afHzXSvX6tbe72caGH&sharer_sharetime=1600910416242&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。
        ping www.baidu.com
        ping www.baidu.com -c 6 -i 0.6  其中 –c count 次数，也就是ping的次数；-i interval 间隔 ，每次ping之间的时间空格
    telnet命令用于登录远程主机，对远程主机进行管理。telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。
    netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。
        netstat -a     //列出所有端口
        netstat -at    //列出所有tcp端口
        netstat -au    //列出所有udp端口
        netstat -l //只显示监听端口
        netstat -lt //只列出所有监听 tcp 端口
        netstat -lu //只列出所有监听 udp 端口
    ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。
    route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；
        可以在*/etc/rc.local中添加route命令来保证该路由设置永久有效。
    arp命令用于操作主机arp缓冲区，可以显示arp缓冲区的所有条目、删除指定条目或增加静态IP地址与MAC地址的对应关系
        arp -a
        arp -v
    traceroute命令用于追踪数据包在网络上传输时的全部路径，它默认发送的数据包大小是40字节通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。
        traceroute www.baidu.com
    host命令是常用的分析域名查询工具，可以检测域名系统工作是否正常
    tcpdump命令是一款抓取数据包的工具，它可以打印所有经过网络接口的数据包的头信息，也可以使用-w选项将数据包保存到文件中，方便以后分析。
```
#### [不可不知的7个JDK命令](https://www.cnblogs.com/wupeixuan/p/12965240.html)
```markdown
javap:使用javap可以查看Java字节码反编译的源文件。
jsp:jps 是用来查询当前所有进程 pid 的。
jstat: jstat 主要用于监控 JVM，主要是 GC 信息，在性能优化的时候经常用到，
jcmd: jcmd 可以查看 JVM 信息。
jmap: jmap 打印出 Java 进程内存中 Object 的情况，或者将 JVM 中的堆以二进制输出成文本。
jhat: jhat 分析 Java 堆的命令，可以将堆中对象以 html 的形式显示出来，支持对象查询语言 OQL
jsatck: jstack 是堆栈跟踪工具，主要用于打印给定进程 pid 的堆栈信息，
    一般在发生死锁或者 CPU 100% 的时候排查问题使用，可以去查询当前运行的线程以及线程的堆栈信息是什么情况
[给你的Java程序拍个片子吧：jstack命令解析](https://www.cnblogs.com/jay-huaxiao/p/12865552.html)
整机 top:    uptime
CPU vmstat -n 2 3  # 每两秒采样一次，采样三次。
    查看额外： mpstat -P ALL 2 查看所有CPU核信息
              pidstat -u 1 -p 进程编号  每个进程使用cpu的用量分解信息
内存 free 应用程序可用内存数 free -m ,free -g  查看内存的单位
    查看额外 pidstat -p 进程号 -r 采样间隔秒数
硬盘 df  查看磁盘剩余空闲数  df -h
磁盘IO iostat   磁盘I/O性能评估 iostat -xdk 2 3
    查看额外 pidstat -d 采样间隔秒数 -p 进程号
网络IO ifstat 默认本地没有，下载    ifstat l  查看网络I/O
```
#### [1.分析Linux进程的6个方法，我全都告诉你](http://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247487818&idx=3&sn=a7f1dbff16e0f2ff3aa0e5af69a62f1c&chksm=ce405a9ef937d3886a7a3eb7fce31e57ec533b18d80b12559d449ece5c49ec58563398293dd8&mpshare=1&scene=23&srcid=&sharer_sharetime=1590881539719&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
ps:  --列出当前系统进程的快照。
   # ps -ef  -- 列出系统内经常信息 
   # ps -ef|grep intresting  -- 第一列PID代表进程号，
strace: --跟踪进程内部的系统调用和信号
    # strace ./time_test  -- strace后面跟着启动一个进程，可以跟踪启动后进程的系统调用和信号
pstack: -- 打印出运行中程序的堆栈信息
    # pstack pid -- 能看到当前线程运行中的堆栈信息
pstree: -- 按树形结构打印运行中进程结构信息
    # pstree -p 11811
gdb: -- 可以查看程序的堆栈、设置断点、打印程序运行时信息，甚至还能调试多线程程序
```
#### [Linux 性能分析之内存篇](https://www.cnblogs.com/bakari/p/10486818.html)
```markdown
内存信息
    1.cat /proc/meminfo 查看文件记录着比较详细的内存配置信息
    2.free
    3.dmidecode -t memory
    4.vmstat l 用于进行系统全局分析和CPU分析
进程内存使用情况分析
    1.top/htop:按照 CPU 利用率进行排序的
    2.ps aux --sort=rss | head -n 查看 Top n 进程占用内存情况
    3.pmap -x pid  查看进程在哪些地方用了多少内存
```
#### 日志文件找出现最频繁的k个word，以及考虑大文件分割处理
#### linux命令 对日志文件的IP出现的次数进行统计
```java
grep -i -o -E "([0-9]{1,3}\.){3}[0-9]{1,3}" test1.txt | sort -n | uniq -c | sort -n -r | head -6
grep命令 用于文本搜索

-E：用于使用正则匹配

-o：只显示匹配的部分

-i：忽略大小写

sort命令用于排序

-n：数值排序

-r：倒序排序

uniq命令用于去重

-c：显示重复次数

head -6命令显示前6行
```
#### 检索文件内容
```markdown
语法：grep [options] pattern file  作用：查找文件里符合条件的字符串
grep "moo" target*  -- 去当前目录下的target开头文件中查找包含moo的字符
管道操作符 | 将指令连接起来，前一个指令的输出作为后一个指令的输入
find -xxx | grep "abc"
    使用管道注意的要点：
        - 只处理前一个命令正确输出，不处理错误输出
        - 右边命令必须能够接受标准输入流，否则传递过程中数据会被抛弃
        - sed,awk,grep,cut,head,top,less,more,wc,join,sort,split等等
```
#### 对文件内容做统计
```markdown
语法： awk [options] 'cmd' file 一次读取一行，按输入分隔符进行切片
    awk '{print $1,$4}' test.txt 取出test.txt文件中第一个和第四个切片
    awk '$1=="tcp" && $2==1{print $0}' test.txt 取出test.txt文件中第一个和第四个切片
```
#### 批量替换文件内容
```markdown
语法: sed [option] 'sed command' filename  流编辑器 适合对文本的行内容进行处理
    sed -i 's/^Str/String/' text.txt -- 将文件中的Str替换为String并且写入文件（一行文件只替换首次出现的）
    sed -i 's/\.$/\;/'  text.txt -- 将文件中末尾的.替换为;并且写入文件
    sed -i 's/^Str/String/g' text.txt -- 将文件中的Str替换为String并且写入文件（全文替换）
    sed -i '/Integer/d' text.txt --将文件中包含Integer的文件行删除
```

## Linux命令总结
[当前标签：每天学习一个linux命令](https://www.cnblogs.com/huchong/tag/%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/)
[随笔分类 - Shell](https://www.cnblogs.com/surpassme/category/1257268.html)
#### 一些实用的快捷键
```markdown
- Ctrl + L 用于清理终端的内容，就是清屏的作用。== clear
- Ctrl + D 给终端传递 EOF （End Of File，文件结束符），在运行程序时很有用。
    比如退出root用户身份，就可以用Ctrl+D。如果在命令行提示符后什么也不输入的情况下直接按下这组快捷键，那么就会关闭当前的终端；
- Shift + PgUp 用于向上滚屏，与鼠标的滚轮向上滚屏是一个效果；
- Shift + PgDn 用于向下滚屏，与鼠标的滚轮向下滚屏是一个效果。
- Ctrl + A 光标跳到一行命令的开头。一般来说，Home 键有相同的效果；
- Ctrl + E 光标跳到一行命令的结尾。一般来说，End 键有相同的效果；。
- Ctrl + U 删除所有在光标左侧的命令字符；
- Ctrl + K 删除所有在光标右侧的命令字符；
- Ctrl + W 删除光标左侧的一个“单词”，这里的“单词”指的是用空格隔开的一个字符串。例如 -a 就是一个“单词”；
- Ctrl + Y 粘贴用 Ctrl + U、 Ctrl + K 或 Ctrl + W “删除”的字符串，有点像“剪切-粘贴”。
- Ctrl + R 搜索先前使用的命令
- Ctrl + C 终止当前命令
- ESC + T 调换光标前的两个单词
```
#### 根目录
```markdown
- bin：表示“二进制文件”（我们知道可执行文件是二进制的）。包含了会被所有用户使用的可执行程序；
- boot：包含与 Linux 启动密切相关的文件；
- dev：表示“设备”，包含外设。它里面的子目录，每一个对应一个外设。比如代表我们的光盘驱动器的文件就会出现在这个目录下面；
- etc：表示“…等等”，包含系统的配置文件。至于为什么在/etc下面存放配置文件，按照原始的Unix说法（Linux文件结构参考Unix的教学实现MINIX），这下面放的都是一堆零零碎碎的东西，就叫etc好了。
- home：用户的私人目录。放置私人的文件，有点类似Windows中的Documents这个文件夹，也叫“我的文档”。Linux中的每个用户（除了大管家用户，也就是超级用户root外。
    root因为太厉害，拥有所有权限，所以比较“任性”，跟普通用户不住在一起）都在home目录下有自己的一个私人目录。比如我的用户名是oscar，那么我的私人目录就是/home/oscar；如果另一个用户叫 john，那么他的私人目录就是/home/john；
- lib：表示“库”，包含被程序所调用的库文件。例如.so结尾的文件，在Windows下这样的库文件是以.dll结尾的；
- media：表示“媒体”。当一个可移动的外设（比如USB盘、SD卡、DVD、光盘等等）插入电脑时，Linux就可以让我们通过media的子目录来访问这些外设中的内容。
- mnt：表示“挂载”。有点类似media，但一般用于临时挂载一些装置；
- opt：表示“可选的应用软件包”，用于安装多数第三方软件和插件；
- root：超级用户 root 的家目录/主目录。一般用户的家目录是位于 /home 下，不过 root 用户是个例外。之前的课程我们也提到过，root 是整个系统的超级用户，拥有一切权限，初学者请慎用此用户模式；
- sbin：表示“系统二进制文件”。比起 bin 目录多了一个前缀 system，所以包含的是系统级的重要可执行程序；
- srv：表示“服务”。包含一些网络服务启动之后所需要取用的数据；
- tmp：表示“临时的”。普通用户和程序存放临时文件的地方；
- usr：表示“Unix操作系统软件资源”（也是个历史遗留的命名）。这个目录是最庞大的目录之一。有点类似Windows中的 C:\Windows和C:\Program Files这两个文件夹的集合。在这里面安装了大部分用户要调用的程序；
- var：表示“动态的，可变的”。通常包含程序的数据，比如一些log（日志）文件，记录电脑中发生了什么事。
```
#### 系统与硬件相关命令
```markdown
$ lspci -- 命令可以查看所有的 pci 设备，比如主板，声卡等
$ more /proc/cpuinfo -- 查看CPU信息
$ cat /proc/cpuinfo | grep “physical id”  | sort | uniq | wc -l -- 查看 CPU 的个数
$ cat /proc/cpuinfo |grep "processor" | wc -l -- 查看系统所有的逻辑CPU个数
$ more /proc/meminfo -- 查看内存的信息
$ fdisk -l -- 查看磁盘分区的信息
```
#### 系统服务管理工具
```markdown
$ systemctl status httpd.service -- 查看这个服务状态
$ systemctl start httpd.service -- 通过systemctl启动一个服务
$ systemctl stop httpd.service -- 停掉此服务
$ systemctl restart httpd.service -- 重启服务
$ systemctl try-restart httpd.service #只会在服务已经运行的状态下重启服务
$ systemctl reload httpd.service #重新加载配置文件
$ systemctl disable httpd.service -- 关闭服务
```
#### pwd和which
```markdown
pwd 命令用于显示当前所在目录；
which 命令用于获取命令的可执行文件的位置。
    pbj@pbj-Veriton-B430:~$ which which
    /usr/bin/which
    pbj@pbj-Veriton-B430:~$ which docker
    /usr/bin/docker
```
#### 目录相关的命令ls，cd和du
```markdown
ls 命令：列出文件和目录
    $ ls -a  //-a ：显示所有文件和目录，包括隐藏的。大写的参数-A，它的作用和小写的-a几乎一样，唯一不同就是-A不列出.和…这两个文件。
    $ ls -l // -l ：详细列表，列出一个显示文件和目录的详细信息列表；
    $ ls -h // -h：以 Ko，Mo，Go 的形式显示文件大小
    $ ls -t // -t：按文件最近一次修改时间排序
cd 命令：切换目录
    $ cd .. // Linux中，一个点表示当前目录，而两个点表示上一级目录：
du 命令：显示目录包含的文件大小
    $ du -h // -h：以 Ko，Mo，Go 的形式显示文件大小
    $ du -a // -a：显示文件和目录的大小
    $ du -s // -s：只显示总计大小
```
#### Linux 文件类型
```markdown
Linux 支持很多文件类型，其中非常重要的文件类型有: 普通文件，目录文件，链接文件，设备文件，管道文件，Socket套接字文件等。
1.普通文件（-）：用于存储信息和数据，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
2.目录文件（d，directory file）：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
3.符号链接文件（l，symbolic link）：保留了指向文件的地址而不是文件本身。
4.字符设备（c，char）：用来访问字符设备比如硬盘。
5.设备文件（b，block）：用来访问块设备比如硬盘、软盘。
6.管道文件(p,pipe):一种特殊类型的文件，用于进程之间的通信。
7.套接字(s,socket)：用于进程间的网络通信，也可以用于本机之间的非网络通信。
```
#### 文件操作
```markdown
cat 命令和 less 命令：显示文件内容
    $ cat 文件路径 // cat 命令：一次性显示文件的所有内容，cat -n 文件显示文件内容上加上行号
    $ less // less命令的好处是它会先读入文件开始的若干行，然后就停在那里，而这若干行的行数取决于终端屏幕的大小。
head 命令和 tail 命令：显示文件的开头和结尾
    $ head 文件路径 // head命令：显示文件开头，默认情况下，head会显示文件的头10行：也可以指定显示的行数，用-n这个参数：
    $ tail 文件路径 // tail命令：显示文件结尾，默认情况下，tail会显示文件的尾10行；也可以指定显示的行数，用-n这个参数：
    $ tail -f 文件路径 // tail命令还可以配合-f参数来实时追踪文件的更新：就会检查文件是否有追加内容，如果有，就显示新增内容：
    $ tail -f -s 4 文件路径 // 默认地，tail -f 会每过1秒检查一下文件是否有新内容。也可以指定间隔检查的秒数，用-s参数：
touch 命令和 mkdir 命令：创建文件和目录
    $ touch test.txt // touch 命令：创建一个空白文件，可以用touch命令同时创建多个文件：
    $ touch "new file.txt" // 要创建的文件的名字里有空格怎么办呢？很简单，加上双引号：
    $ mkdir myfile // mkdir：创建一个目录，还可以用-p参数来递归地创建目录结构。mkdir -p one/two/three
```
#### 文件的复制，移动，删除和链接
```markdown
cp 命令和 mv 命令：拷贝文件和移动文件
    $ cp test.txt test1.txt // cp 命令：拷贝文件或目录，不仅可以拷贝单个文件，还可以拷贝多个文件，也可以拷贝目录。
    $ cp -r myfile // 加上-r或者-R参数。拷贝的时候，目录中的所有内容（子目录和文件）都会被拷贝。
    $ mv test.txt /usr/local/ // mv 命令：移动文件
rm 命令：删除文件和目录
    $ rm -i test.txt // -i 参数：向用户确认是否删除
    $ rm -f test.txt // -f 参数：慎用，不会询问是否删除，强制删除
    $ rm -r myfile // -r 参数：递归地删除
ln 命令：创建链接
    事实上，Linux 下有两种链接类型：
        Physical link：物理链接或硬链接，一旦文件1和文件2之间有了硬链接，那么你修改文件1或文件2，其实修改的是相同的一块儿内容。只不过我们可以用两个文件名来获取到文件内容。
    $ ln file1 file2 // 创建了 file1 的一个硬链接 file2。
        Symbolic link：符号链接或软链接，像我们在Windows下的快捷方式的，其原理很相似。
    $ ln -s file1 file2 // 创建了 file1 的软链接 file2。
```
#### 用户管理
[centos创建新用户](https://blog.csdn.net/nieji3057/article/details/79421874)
```markdown
sudo // 切换到root用户
adduser 命令：添加新用户
    $ adduser pbj // 命令添加新用户
passwd 命令：修改密码
    $ passwd pbj // 修改用户密码
deluser：删除用户
    $ deluser pbj // 删除用户，终端不会提示你确认是否删除，而是直接删除了用户。
    单单用deluser命令，不加参数的话，只会删除用户，但是不会删除在/home目录中的用户家目录。
    $ deluser --remove-home pbj // 想要连此用户的家目录也一并删除，可以加上--remove-home这个参数
```
#### 群组的管理和文件权限管理
```markdown
addgroup：创建群组
delgroup 命令：删除群组
usermod 命令：修改用户账户
    -l：对用户重命名，但是/home目录中的用户家目录名不会改变，需要手动修改；
    -g：修改用户所在群组。此用户的家目录里的所有文件的所在群组会相应改变。
修改文件的所有者和群组
    chown 命令：改变文件的所有者  chown pbj text.xt  // -R 参数：递归设置子目录和子文件
    chgrp 命令：改变文件的群组 chgrp pbj text.txt
chmod 命令：修改访问权限
    d：表示“目录”。就是说这是一个目录；
    l：表示“链接”。就是说这是一个链接；
    r：表示“读”。就是说可以读这个文件；
    w：表示“写”。就是说可以写这个文件，也就是可以修改；
    x：表示“执行，运行”。就是说可以运行这个文件。
chmod 命令：修改文件的访问权限
    chmod 600 text.txt // 文件的访问权限被修改为rw-------，-R 参数：递归地修改访问权限
```
#### 如何查找特定的文件
```markdown
find 语法：find path [options] params  --在指定目录下查找文件（遍历你的实际硬盘，硬盘容量很大的话，那find命令会查找比较久。）
    find -name "text.md"  -- 在当前目录下递归查找text.md文件
    find / -name "text.md" -- 从根目录开始递归查找text.md文件
    find /var -size +10M -- 可以查找/var中大小超过10MB的文件（当然你要以root身份）
    find /var -size -50k -- 表示查找小于50K的文件：
    find ~ -name "aa*"  --去父目录下递归查找aa开头的文件
    find ~ -name "aa*"  --去父目录下递归查找aa开头的文件(不区分文件名大小写去查找文件)
    find -name "*.jpg" -atime -7 -- 使用-atime参数，根据文件的最近访问时间查找，表示7天之内，减号表示小于。
    sudo find . -name "new_file" -- -type参数来指定查找的文件类型
    man find: 更多关于find指令的使用说明
locate命令，快速查找
    locate命令不会对你实际的整个硬盘进行查找，而是在文件的数据库里查找记录。
    对于刚创建不久的文件，由于它们还没被收录进文件数据库，因此locate命令就找不到其索引，自然就不会返回任何结果。
    可以用updatedb命令强制系统立即更新文件数据库，但是updatedb命令只能由root用户执行。sudo updatedb
```
#### 数据文件处理
```markdown
grep 命令：筛选数据
    $ grep text file -- text代表要搜索的文本，file代表供搜索的文件。-i参数：忽略大小写，-n参数：显示行号，-v参数：只显示文本不在的行
        -r 参数：在所有子目录和子文件中查找，grep的高级用法：配合正则表达式。
sort 命令：为文件排序
    $ sort name.txt -- sort命令将name.txt文件中的行按照首字母的英文字典顺序进行了排列，并不区分大小写。
        -o参数：将排序后的内容写入新文件，-r参数：倒序排列；-R参数：随机排序；-n参数：对数字排序；
wc 命令：文件的统计
    $ wc name.txt -- 返回分别是行数、单词数、字节数。-l参数：统计行数，-w参数：统计单词数，-c参数：统计字节数；-m参数：统计字符数
uniq 命令：删除文件中的重复内容
    $ uniq repeat.txt -- 把处理后的内容显示出来，-c参数：统计重复的行数；-d参数：只显示重复行的值
    $ uniq repeat.txt unique.txt -- 将处理后的内容储存到一个新文件中
cut 命令：剪切文件的一部分内容
    $ cut -c 2-4 name.txt -- name.txt的每一行只保留第2至第4个字符。-c参数：根据字符数来剪切
```
#### 流和输出重定向
```markdown
“> 和 >>”：重定向到文件
    $ cut -d , -f 1 notes.csv -- 文件每一行用,分割，剪切第一部分的内容输出
    $ cut -d , -f 3 notes.csv -- 文件每一行用,分割，剪切第三部分的内容输出
    $ cut -d , -f 1,3 notes.csv -- 文件每一行用,分割，剪切第一、三部分的内容输出
    $ cut -d , -f 2- notes.csv -- 文件每一行用,分割，剪切第二部分直到最后的内容输出
    $ cut -d , -f 1 notes.csv > students.txt -- 内容重定向到students.txt文件
    $ cut -d , -f 1 notes.csv >> students.txt -- 内容重定向到students.txt文件末尾
“2>，2>>，2>&1”：重定向错误输出
    $ cat not_exist_file.csv > results.txt 2> errors.log -- 假如这个文件确实存在，将其内容写入results.txt文件中否则错误信息写入errors.log文件中
        类似的，2>> 符号用于将标准错误输出重定向到文件末尾。
    $ cat not_exist_file.csv > results.txt 2>&1 -- 将这个命令的所有输出（标准输出和标准错误输出）都重定向到results.txt文件中。
    $ cat not_exist_file.csv >> results.txt 2>&1 -- 将这个命令的所有输出（标准输出和标准错误输出）都重定向到results.txt文件末尾。
```
#### 输入重定向和管道
```markdown
<，<<：从文件或键盘读取
    $ cat < notes.csv -- 将命令的输入重定向为文件内容。
    $ sort -n << END -- 将键盘的输入重定向为某个命令的输入，sort -n的作用是将数值按照从小到大进行排列，输入END来结束输入
    $ wc -m << END -- wc命令用于统计字符等，配合-m参数可以统计字符数。
| ：管道（将两个命令连成管道，简单地说就是将一个命令的输出作为另一个命令的输入）
    $ cut -d , -f 1 notes.csv | sort -- 按学生名字排序
    $ cut -d , -f 1 notes.csv | sort > sorted_names.txt 
    $ du | sort -nr | head -- 根据大小排序目录
    $ sudo grep log -Ir /var/log | cut -d : -f 1 | sort | uniq -- 列出包含关键字的文件
```
#### 监视系统活动和查看进程
```markdown
w 命令：都有谁，在做什么？
    $ w
    $ date
    $ uptime
    $ tload
    $ who
ps 命令和 top 命令：列出运行的进程
    $ ps
    $ ps -ef -- 列出所有进程
    $ ps -efH -- 以乔木状列出所有进程
    $ ps -u 用户名 -- 列出此用户运行的进程
    $ ps -aux | less -- 通过 CPU 和内存使用来过滤进程
    $ ps -aux --sort -pcpu | less -- 根据 CPU 使用率来降序排列
    $ ps -aux --sort -pmem | less -- 根据内存使用率来降序排列
    $ ps -aux --sort -pcpu,+pmem | head -- 将CPU和内存参数合并到一起，并通过管道显示前10个结果
pstree 命令：以树形结构显示进程，ps -axjf 和 pstree 命令的效果比较类似，都能以树形结构显示进程。
```
#### 进程操作和系统重启
```markdown
top：进程的动态列表
Ctrl + C 和 kill 命令：停止进程
    $ kill pid -- 结束一个进程
    $ kill -9 7291 -- kill -9 来立即强制结束进程
    $ killall find -- 结束多个进程
halt 命令和 reboot 命令：停止和重启系统
    $ sudo halt：关闭系统
    $ sudo reboot：重启系统
    $ poweroff -- 立即关机
```
#### 前后台进程，灵活切换
```markdown
& 符号和 nohup 命令：后台运行进程
    $ cp emacs-26.2.tar.gz emacs-26.2-copy.tar.gz & -- 命令最后加了&符号，运行时此进程就成为了后台进程
nohup 命令：使进程与终端分离
    $ nohup cp node-v10.15.3.tar.gz node-v10.15.3-copy.tar.gz -- 使用nohup命令后，输出会被默认地追加写入到一个叫nohup.out的文件里。
    $ nohup cp node-v10.15.3.tar.gz node-v10.15.3-copy.tar.gz &
Ctrl + Z，jobs，bg 和 fg 命令：控制进程的前后台切换
    $ Ctrl + Z：转到后台，并暂停运行
    $ bg 命令：使进程转到后台
    $ jobs 命令：显示后台进程状态
    $ fg 命令：使进程转到前台
```
#### 定时和延时执行
```markdown
date 命令：调节时间
    $ date "+%H" -- 定制输出时间的小时
    $ date "+%H:%M:%S"  
    $ date "+%H时%M分%S秒"
at 命令：延时执行一个程序
    $ sudo apt install at
    $ at 22:10 回车输入要定时执行的命令，可以输入touch file.txt，表示想要在22点10分创建一个文件，名叫file.txt。
    $ at 22:10 tomorrow -- 在明天的 22 点 10 分执行
    $ at 22:10 12/10/19 -- 要在 2019 年 12 月 10 日的 22 点 10 分执行
    $ at now +10 minutes -- 在指定间隔之后执行程序，十分钟之后执行
    $ atq 和 atrm 命令：列出和删除正在等待执行的 at 任务
sleep 命令：休息一会
crontab 命令：定时执行程序
    希望每天的22点10分都在家目录下创建file.txt文件。可以在 crontab 文件里写入：10 22 * * * touch ~/file.txt
```
#### 压缩文件和解压
```markdown
tar命令：将多个文件归档(tar可以同时压缩多个文件。)
    $ tar -cvf sorting.tar sorting/ -- -cvf：创建一个tar归档
    $ tar -cvf archive.tar file1.txt file2.txt file3.txt -- 把file1.txt，file2.txt，file3.txt 归档为 archive.tar
    $ tar -tf sorting.tar -- -tf：显示归档里的内容，并不解开归档
    $ tar -rvf archive.tar file_extra.txt -- -rvf：追加文件到归档
    $ tar -xvf sorting.tar -- -xvf：解开归档
    $ tar -zcvf sorting.tar.gz sorting -- 用tar命令同时归档和压缩，-zcvf：归档，然后用gzip来压缩归档
    $ tar -zxvf sorting.tar.gz -- 用tar命令同时归档和解压缩
    $ tar -jcvf sorting.tar.bz2 sorting/ -- -jcvf：归档，然后用bzip2来压缩归档
    $ tar -jxvf sorting.tar.bz2 -- 解压
gzip和bzip2命令：压缩归档(gzip和bzip2不能同时压缩多个文件，一次只能压缩一个文件。)
    $ gzip sorting.tar -- 将sorting.tar文件改变为sorting.tar.gz压缩文件
    $ bzip2 sorting.tar -- 将sorting.tar压缩为sorting.tar.bz2压缩文件
    $ gunzip sorting.tar.gz -- 解压
    $ bunzip2 sorting.tar.bz2 -- 解压
    zcat，zmore，zless 命令就可以显示用 gzip 命令压缩的文件的内容
zip/unzip和rar/unrar 命令：压缩/解压zip和rar文件
    $ sudo apt install unzip     # 这是在 Debian 一族中的安装方式 
    $ sudo apt install zip      # 这是在 Debian 一族中的安装方式
    $ unzip archive.zip -- 解压 .zip 格式的压缩文件
    $ zip -r sorting.zip sorting/ -- 压缩一下我们的 sorting 目录
    $ sudo apt install unrar     # 这是在 Debian 一族中的安装方式
    $ sudo apt install rar     # 这是在 Debian 一族中的安装方式
    $ unrar e archive.rar -- 解压 .rar 格式的压缩文件
    $ rar a sorting.rar sorting/ -- 压缩一下我们的 sorting 目录
```
#### 文件传输和同步
```markdown
wget ：下载文件
scp ：网间拷贝
ftp & sftp ：传输文件
rsync ：同步备份
```

## Linux Shell脚本总结
#### 查看系统中所有可用的Shell和用户Shell
```markdown
$ cat /etc/shells
用户登录到Linux系统时，由/etc/passwd文件决定用户将要使用哪种shell。
$ grep root /etc/passwd
$ echo $SHELL
```
#### Shell脚本
```markdown
Shell脚本是利用Shell的功能所写的一个程序，是纯文本格式，将一些Shell的语法与指令写在里面，利用正则表达式、命令管道以及数据流重定向等功能以实现我们需要的功能。
Shell脚本一般由以下几部分组成：
    - Shell关键字--例如：if...else,for do...done
    - Shell命令-- 例如: export,echo,exit,pwd,return
    - Linux命令-- 例如： date,rm,mkdir
    - 文本处理功能--例如：awk,cut,sed,grep
    - 函数--
    - 控制流语句--例如if..then...else或执行重复操作的Shell循环
```
#### 编写第一个Shell脚本
```markdown
$ vi my_first_script文件输入
#!/bin/bash
# my first script

ls -l .*
保存文件
$ chomd 755 my_first_script # 修改文件权限
$ ./my_first_script # 运行脚本
```
#### 
