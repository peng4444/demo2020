# 学习基础知识
## 计算机基础
### 二进制编码【原码，反码，补码】
![image-20201121164250068](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201121164250.png)
[计算机二进制中的原码，反码，补码](https://www.cnblogs.com/codeshell/p/14023387.html)
```markdown
可以总结出，对于N 位的二进制数：
    - 无论是表示有符号数还是无符号数，都能表示2^N个数字。
    - 若用于表示无符号数，则能表示的范围是[0, 2^N - 1]。
    - 若用于表示有符号数，则能表示的范围是[-2^(N-1), 2^(N-1) - 1]。
        - 需要注意，在有符号数中，对于符号位是1，后面N-1位全是0，这种情况表示的是-2^(N-1)(也就是所能表示的最小值)，而不是-0。
        - 实际上是将-0这种情况解释成了最小值，否则就会出现+0和-0两个0。
原码：原码就是除符号位外的其他位，保存该二进制数的绝对值。
    加法：3:0011,2:0010,3+2=5:0101
数字溢出：空间大小是有限制的，所以计算机中的数字也是有范围的，即上限和下限，如果数字超出限制，就会产生溢出。
    超出上限叫上溢出，超出下限叫下溢出。而溢出的部分会直接被舍去。
    - 对于N位二进制有符号整数，所能表示的范围是[-2^(N-1), 2^(N-1) - 1]。
    - 由于溢出的部分会被舍去，那么最大值加1，将发生上溢出，变为最小值；最小值减1，将发生下溢出，变为最大值。
    比如：2^(N-1)-1+1=-2^(N-1)
    Java 中int 类型的最大、最小值分别是：
        最大值：Integer.MAX_VALUE，是 2147483647。2^31 -1
        最小值：Integer.MIN_VALUE，是 -2147483648。-2^31
反码：正数的反码等于其原码，负数的反码是其原码除符号位外，按位取反。
补码：正数的补码等于其原码，负数的补码是其反码加1。**真实的计算机中的二进制是用补码表示的，而不是原码。**
    2：原码：0010，反码：0010，补码：0010
    -2：原码：1010，反码：1101，补码：1110
    减法：3-2=3+(-2) = 0011+1110=10001=0001，高位舍去
```
### Java中符号>>和>>>的区别
```markdown
位移运算：**注意：位移运算都是补码进行操作**
    右移运算符：向右移动位近似表示除以2，十进制的奇数转化为二进制数后，在向右移时，最右边的被直接抹去，说明向右移对于奇数并非完全相当于除以。
    **在左移<<与右移>>两种运算中，符号位均参与移动，除负数往右移动，高位补1之外，其他情况均在空位处补0。**
    左移运算符：左移运算由于符号位参与向左移动，在移动后的结果中 最左位可能是1或者0，
        即正数向左移动的结果可能是正也可能是负，负数向左移动的结果同样可能是正也可能是负。
对于三个大于号的>>>无符号向右移动(注意不存在<<<>>>无符号向左移动的运算方式）
    当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值是1。符号位参与移动。无符号向右移动之后不存在负数。
java中有三种移位运算符
左移<<      :     左移运算符，num << 1,相当于num乘以2
右移>>      :     右移运算符，num >> 1,相当于num除以2
无符号右移>>>    :     无符号右移，忽略符号位，空位都以0补齐
public static void main(String[] args) {
        int a = 35;
        System.out.println("35右移："+(a>>1));// 17
        System.out.println(" 35左移："+(a<<1));// 70
        System.out.println("35无符号右移："+(a>>>1));// 17
        int b = -35;
        System.out.println("-35右移："+(b>>1));// -18
        System.out.println(" -35左移："+(b<<1));// -70
        System.out.println(Integer.toBinaryString(-35));//都是32位数进行操作
        System.out.println("-35无符号右移："+Integer.toBinaryString(b>>>1));//-35无符号右移：2147483630
        int c = 99;
        System.out.println("99右移："+(c>>1));// 49
        System.out.println(" 99左移："+(c<<1));// 198
        int d = -99;
        System.out.println("-99右移："+(d>>1));// -50
        System.out.println(" 99左移："+(d<<1));// -198
    }
```
### 浮点数表示
![image-20201130154313678](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201130154320.png)
```markdown
浮点数表示就是如何用二进制数表示符号、指数和有效数字。当前业界流行的浮点数标准是IEEE754该标准规定了
    4种浮点数类型单精度、双精度、延伸单精度、延伸双精度。**浮点数无法表示零值**
    单精度类型：4字节数  正数范围（1.4e-45至3.4e+38）     负数范围（-3.4e+38至-1.4e-45）
    双精度类型：8字节数  正数范围（4.9e-324至1.798e+308） 负数范围（-1.798e+308至-4.9e-324）
单精度浮点数格式：
    I. 符号位。在最高二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数。
    II. 阶码位。在符号位右侧分配8位用来存储指数，IEEE754标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。指数范围为[-126,127]
    III. 尾数位。最右侧分配连续的23位用来存储有效数字，IEEE754标准规定尾数以原码表示。为了节约存储空间，将符合规格化尾数的首个1省略，所以尾数表面上是23位，却表示24位二进制数。
为什么偏移值2e(n-1) -1 而不是 2e(2n-1) 呢？
    因为8个二进制位能表示指数的取值范围为[-128,127]，现在将指数变成移码表示，即将区间[-128,127]，正向平移到正数域，区间里的每个数都需要加上128，
从而得到阶码范围为[0,255]。由于计算机规定阶码全为0或全为1两种情况被当作特殊值处理（全0被认为是机器零，全1被认为是无穷大），去除这两个特殊值，
阶码的取值范围变成了[1,254]。如果偏移量不变仍为128的话，则根据换算关系公式[x]阶= x+128得到指数的范围变成[-127,126]，指数最大只能取到 126，显然会缩小浮点数能表示的取值范围。
所以IEEE754标准规定单精度的阶码偏移量为2e(n-1) -1 （即127），这样能表示的指数范围为[-126,127], 指数最大值能取到127。
```
![image-20201130160149195](https://raw.githubusercontent.com/peng4444/picgo/main/img/20201130160149.png)
### 浮点数加减法
```markdown

```

## 正则表达式
[正则表达式](https://blog.csdn.net/qq_39331713/article/details/82871510)
[正则表达式（代码java版）](https://www.cnblogs.com/mxjhaima/p/13737903.html)
### 1.正则基础知识点：
#### 1.元字符->元字符是构造正则表达式的一种基本元素。
```markdown
语法：
    元字符	    说明
    .	    匹配除换行符以外的任意字符
    \w	    匹配字母或数字或下划线或汉字
    \s	    匹配任意的空白符
    \d	    匹配数字
    \b	    匹配单词的开始或结束
    ^	    匹配字符串的开始
    $	    匹配字符串的结束
练习：
    匹配有abc开头的字符串：\babc或者^abc
    匹配8位数字的QQ号码：\d\d\d\d\d\d\d\d\d$
    匹配1开头11位数字的手机号码：^1\d\d\d\d\d\d\d\d\d\d$
```
#### 2. 重复限定符 ->把重复部分用合适的限定符替代
```markdown
语法：
    语法	        说明
    *	    重复零次或更多次
    +	    重复一次或更多次
    ?	    重复零次或一次
    {n}	    重复n次
    {n,}	重复n次或更多次
    {n,m}	重复n到m次
练习：
    匹配8位数字的QQ号码：^\d{8}$
    匹配1开头11位数字的手机号码：^1\d{10}$
    匹配银行卡号是14~18位的数字：^\d{14,18}$
    匹配以a开头的，0个或多个b结尾的字符串: ^ab*$
```
#### 3.分组
>> 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。
```markdown
匹配字符串中包含0到多个ab开头：^(ab)*
```
#### 4. 转义
>> 要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。
```markdown
要匹配以(ab)开头： ^(\(ab\))*
```
#### 5.条件或
>> 正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。
```markdown
联通有130/131/132/155/156/185/186/145/176等号段: ^(130|131|132|155|156|185|186|145|176)\d{8}$
```
#### 6. 区间
```markdown
正则提供一个元字符中括号 [] 来表示区间条件。
    限定0到9 可以写成[0-9]
    限定A-Z 写成[A-Z]
    限定某些数字 [165]
联通有130/131/132/155/156/185/186/145/176等号段: ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```
### 2.正则进阶知识点：
#### 1. 零宽断言
```markdown
1.断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，
    意思正则也可以像人类那样断定什么什么，比如"ss1aa2bb3",正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.
2.零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。
爬虫抓取csdn里的文章阅读量:"<span class="read-count">阅读数：641</span>"
1.正向先行断言（正前瞻）：
    语法：（?=pattern）
    作用：匹配pattern表达式的前面内容，不返回本身。  
     String reg=".+(?=</span>)";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=pattern.matcher(test);
     while(mc.find()){
       System.out.println("匹配结果：")
       System.out.println(mc.group());
     }
    //匹配结果：
    //<span class="read-count">阅读数：641
    可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：
    String reg="\\d+(?=</span>)";
    String test = "<span class=\"read-count\">阅读数：641</span>";
    Pattern pattern = Pattern.compile(reg);
    Matcher mc=    pattern.matcher(test);
    while(mc.find()){
      System.out.println(mc.group());
    }
    //匹配结果：
    //641
2.正向后行断言（正后顾）:
    语法：（?<=pattern）
    作用：匹配pattern表达式的后面的内容，不返回本身。
     //(?<=<span class="read-count">阅读数：)\d+
     String reg="(?<=<span class=\"read-count\">阅读数：)\\d+";
     String test = "<span class=\"read-count\">阅读数：641</span>";
     Pattern pattern = Pattern.compile(reg);
     Matcher mc=    pattern.matcher(test);
             while(mc.find()){
                 System.out.println(mc.group());
             }
    //匹配结果：
    //641
3.负向先行断言（负前瞻）
    语法：(?!pattern)
    作用：匹配非pattern表达式的前面内容，不返回本身。
    比如有一句 “我爱祖国，我是祖国的花朵”现在要找到不是'的花朵'前面的祖国
    用正则就可以这样写：祖国(?!的花朵)
4.负向后行断言（负后顾）
    语法：(?<!pattern)
    作用：匹配非pattern表达式的后面内容，不返回本身。
```
#### 2. 捕获和非捕获
```markdown
单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”
捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。
而根据命名方式的不同，又可以分为两种组：
    1.数字编号捕获组：
    语法：(exp)
    解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。
    比如固定电话的：020-85653333
    他的正则表达式为：(0\d{2})-(\d{8})
    按照左括号的顺序，这个表达式有如下分组：
     String test = "020-85653333";
             String reg="(0\\d{2})-(\\d{8})";
             Pattern pattern = Pattern.compile(reg);
             Matcher mc= pattern.matcher(test);
             if(mc.find()){
                 System.out.println("分组的个数有："+mc.groupCount());
                 for(int i=0;i<=mc.groupCount();i++){
                     System.out.println("第"+i+"个分组为："+mc.group(i));
                 }
            }
    输出：分组的个数有：2
         第0个分组为：020-85653333
         第1个分组为：020
         第2个分组为：85653333
    2.命名编号捕获组：
      语法：(?<name>exp)
      解释：分组的命名由表达式中的name指定
      比如区号也可以这样写:(?<quhao>\0\d{2})-(?<haoma>\d{8})
      按照左括号的顺序，这个表达式有如下分组：
      String test = "020-85653333";
              String reg="(?<quhao>0\\d{2})-(?<haoma>\\d{8})";
              Pattern pattern = Pattern.compile(reg);
              Matcher mc= pattern.matcher(test);
              if(mc.find()){
                  System.out.println("分组的个数有："+mc.groupCount());
                  System.out.println(mc.group("quhao"));
                  System.out.println(mc.group("haoma"));
              }
        输出：分组的个数有：2
             分组名称为:quhao,匹配内容为：020
             分组名称为:haoma,匹配内容为：85653333
    3.非捕获组：
      语法：(?:exp)
      解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。
    
```
#### 3. 反向引用
```markdown
捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。
根据捕获组的命名规则，反向引用可分为：
    1.数字编号组反向引用：\k
        或\number
    2.命名编号组反向引用：\k
        或者\'name'
```
#### 4. 贪婪和非贪婪
```markdown
贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。
特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。
```
#### 5. 反义
```markdown
正则也提供了一些常用的反义元字符：
    元字符	            解释
    \W	        匹配任意不是字母，数字，下划线，汉字的字符
    \S	        匹配任意不是空白符的字符
    \D	        匹配任意非数字的字符
    \B	        匹配不是单词开头或结束的位置
    [^x]	    匹配除了x以外的任意字符
    [^aeiou]	匹配除了aeiou这几个字母以外的任意字符
```
## 