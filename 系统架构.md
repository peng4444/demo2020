# 系统 架构
## 一、系统
### 1.缓存
#### 1.缓存特征
```markdown
命中率：当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高。
最大空间：缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。
        当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。
淘汰策略
    FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用
    FIFO，使得最先进入的数据（最晚的数据）被淘汰。
    LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距
        离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。
    LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。
```
#### 2. 缓存位置
```markdown
浏览器:当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。
ISP:网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。
反向代理:反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。
本地缓存:使用 Guava Cache将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。
分布式缓存:使用 Redis、Memcache等分布式缓存将数据缓存在分布式缓存系统中。相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。
           不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。
数据库缓存:MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。
Java内部的缓存:Java为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean这六种包装类缓冲池。
CPU多级缓存:CPU为了解决运算速度与主存IO速度不匹配的问题，引入了多级缓存结构，同时使用MESI等缓存一致性协议来解决多核CPU缓存数据一致性的问题。
```
#### 3. CDN
[聊聊 CDN 缓存与浏览器缓存](https://www.cnblogs.com/upyun/p/10862511.html)
```markdown
内容分发网络（Content distribution network，CDN）是一种互连的网络系统，
        它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。
CDN 主要有以下优点：
        更快地将数据分发给用户；
        通过部署多台服务器，从而提高系统整体的带宽性能；
        多台服务器可以看成是一种冗余机制，从而具有高可用性。
```
#### 4.缓存问题
```markdown
缓存穿透:指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。
解决方案：
    对这些不存在的数据缓存一个空数据；
    对这类请求进行过滤。
缓存雪崩:指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。
在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。
解决方案：
    为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；
    为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
    也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。
缓存一致性:缓存一致性要求数据更新的同时缓存数据也能够实时更新。
解决方案：
    在数据更新的同时立即去更新缓存；
    在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。
    要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。
缓存 “无底洞” 现象：指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。
产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次
    批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。
解决方案：
    优化批量数据操作命令；
    减少网络通信次数；
    降低接入成本，使用长连接 / 连接池，NIO 等。
```
#### [缓存系统设计：缓存击穿，缓存雪崩，缓存穿透，缓存预热](https://www.cnblogs.com/fudashi233/p/10706750.html)
```markdown
1.- 缓存击穿:
假设一个缓存系统中存在一个热Key，每分每秒都有大量的请求访问这个key，那么当这个热key因为过期而失效，一瞬间所有的请求直接打到DB上，这种场景称做缓存击穿。
解决方案：
    1.互斥锁
    当缓存过期时，常见的逻辑是直接请求DB，然后再set回缓存中。为了避免缓存击穿的问题，可以在请求DB的地方加一个锁（如果是分布式系统就需要使用分布式锁），
    争取到锁的就去访问DB，没争取到的就阻塞一段时间再请求缓存，减少直接打到DB的请求。
    2.永不过期
    不给key设置有效期，让key永不过期，然后以定时任务的形式，主动去更新缓存。
    3.逻辑过期
    同样不给key设置有效期，而是将expired值作为缓存数据的一个字段放入缓存中，取出来时校验一下是否过期，如果过期了则重新设置有效期，并起一个异步线程去更新这缓存。
2.- 缓存雪崩
假设一个缓存系统中，大量的key用的都是同一个expired值，那么在某一瞬间，这些key可能会集体全部失效，所有的请求直接打到DB上，这种场景称作缓存雪崩。
解决方案：    
    1.随机过期时间
    将数据写入缓存时往往会设置一个expired值，为了避免在某一时间统统全部过期，可以在expired值的基础上加上1~5min的随机值，避免这种情况。这样缓存就不会在某一瞬间突然全部过期了。
3.- 缓存穿透
    当用户访问一个不存在的key时，缓存取不到，按逻辑就是从库里面取，这种请求一多，打到DB的请求也就增加了，这种场景称作缓存击穿。
解决方案：    
    1.缓存不存在的值
    如果查询到一个空的结果时，可以仍然将这个空的结果进行缓存，下次在请求的话就会这就返回这个空的结果而不是请求DB。
    当然，如果这种请求一多，存储里就会存储大量这种无效值，对缓存的空间也是一种压力，所以推荐使用下面BloomFilter的方式。
    2.BloomFilter
    BloomFilter的特性就是当BloomFilter认为有数据时，是可能有，当认为没有数据时，那就是真没有。故可以利用BloomFilter的特性，挡掉这些不存在的请求。
4.- 缓存预热 ：
    系统刚启动，缓存还未完全构建，但是用户不会管这么多，直接一股脑的访问过来，请求又直接打到DB了。
    如果遇到这种场景，可以利用缓存预热的思想，在系统启动时调用一个后台接口，构建一遍缓存。
```
#### [缓存，确实很香，却也很受伤！](https://www.cnblogs.com/niejunlei/p/12914336.html)
```markdown
最开始使用缓存的场景，
    一些数据库里存储的不变的配置信息，服务启动时，直接加载到本地公共模块，方便其它功能模块共享使用。这便是最基本，最简单的本地缓存应用。
1.- 缓存穿透:对于未“命中”的数据，则需要穿过缓存层，进一步去持久化数据层获取。此种情景，我们称之为缓存穿透。
2.- 缓存一致性：当应用发生数据操作变更，我们则需要将变更同时更新到持久层及缓冲层。“先”与“后”的问题，我们也称之为缓存一致性问题。
    如果先更新缓存，则可能面临持久层更新失败，产生缓存脏数据的问题。
    然则，假如先更新持久层，我们又不得不面对从持久层更新成功之后到缓存更新之前这个间期，缓存对外提供旧数据的窘境。
3.- 缓存与更新
    缓存更新一致性的问题，从实际应用情景来讲，可以细分为强一致性需求，弱一致性需求及最终一致性需求。
4.- 缓存穿透的危害
    1、数据暂时不存在于缓存中。
    2、数据从来不存在，当一个查询不存在数据的请求到来，其必然会穿过缓存，达到持久化存储层。
5.- 缓存雪崩    
    如果缓存由于某些原因一时不能提供正常服务时，所有的请求就会穿透到持久存储层，造成存储层极端宕机情况发生。
    1.缓存的高可用是应对缓存雪崩的首要保障：主从，读写分离，动态扩容，一致性均衡，异地容灾等。
    2、服务治理之限流、熔断降级。限流即对异常流量的控制；熔断、降级标的核心服务资源的保护。
```
#### [浏览器缓存机制](https://www.cnblogs.com/liutianzeng/p/11294955.html)
```markdown
1.为什么要使用浏览器缓存
　　1.1减少网络请求
　　1.2加快浏览器响应时间
2.浏览器是如何缓存的呢？
    2.缓存位置
    从缓存位置上来说一共有四种，且各自有优先级，查找缓存时会依次查找，当都没有找到时，才会去请求网络。
    Service Worker:是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。
    Memory Cache:也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。
    Disk Cache：也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。
    Push Cache：推送缓存是HTTP/2中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话Session中存在，一旦会话结束就被释放，并且缓存时间也很短暂。
3.缓存过程分析
    第一次发起HTTP请求
    浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
    浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
    以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，
    那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，
    这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。
```
#### [系统性能提升利刃 | 缓存技术使用的实践与思考](https://www.cnblogs.com/amap_tech/p/11356703.html)
#### [设计一个完美的http缓存策略](https://www.cnblogs.com/chenlei987/p/11383242.html)
#### [并发环境下，先操作数据库还是先操作缓存？](https://www.cnblogs.com/jay-huaxiao/p/11462232.html)

### 2.系统重构
[系统重构的道与术](https://yq.aliyun.com/articles/739598?utm_content=g_1000094622)

[重构：改善饿了么交易系统的设计思路](https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653200817&idx=2&sn=d632705e7c92f65e912057cb1117cf7b&chksm=8c99d36bbbee5a7d87b7f13bf925035f4e39eb5929d4d6d41787d37b9e53c052ae47ec813024&mpshare=1&scene=23&srcid=&sharer_sharetime=1576630307918&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```
个人简单的理解，道就是思想，术是方法。可谓有道无术，术尚可求也；有术无道，止于术。
分别从重构的基本思路和原则，以及常见重构方案的应用来分别讲讲系统重构的“道与术”。
```
![重构工作遵循的基本思路和原则](https://ucc.alicdn.com/pic/developer-ecology/d05cc91a0a104e3da0d29c7958484d5b.png)

![要注意考虑哪些问题](https://ucc.alicdn.com/pic/developer-ecology/7b860b3ea3e74d93820e419895a90e9a.png)
### 3.系统开发流程
[研发模式和流程的再思考](https://www.cnblogs.com/jackyfei/p/12914933.html)
### 4.线上故障处理
[线上故障处理手册](https://www.cnblogs.com/stoneFang/p/12977116.html)
```markdown

```
[6000+字，30+张图。JAVA线上故障排查全套路总结。](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247487437&idx=2&sn=4e97c161a5c77df1730e8f90363a18a6&chksm=cea24006f9d5c9108a4026bf0f726e39f2441e8807b1ace4cc43011f5a938d22d17f78b8fe8a&mpshare=1&scene=23&srcid=&sharer_sharetime=1590633319101&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)
```markdown
CPU:
磁盘:
内存:
GC问题:
网络:
```
### 5.性能优化
[记一次接口性能优化实践总结：优化接口性能的八个建议](https://www.cnblogs.com/jay-huaxiao/p/12995510.html)
```markdown
- 数据量比较大，批量操作数据入库
- 耗时操作考虑异步处理
- 恰当使用缓存
- 优化程序逻辑、代码
- SQL优化
- 压缩传输内容
- 考虑使用文件/MQ等其他方式暂存，异步再落地DB
- 跟产品讨论需求最恰当，最舒服的实现方式
```

## 二、架构
### [架构模式：MVC与MVVM](https://www.cnblogs.com/ivaneye/p/10096598.html)
```markdown
MVC描述了「Model,View,Controller」三者之间的关系，用以解决「有展示界面的系统」「界面开发与业务逻辑的耦合问题」
MVVM描述了[Model,View,ViewModel(和Binder)」三者之间的关系，用以解决「有展示界面的系统」「界面开发与业务逻辑的耦合问题」。
```
### [架构演变之路：为何要搞微服务架构？](https://www.cnblogs.com/arthinking/p/12812786.html)
```markdown
    1.软件架构的发展史  单体->分布式单体->SOA->微服务（MSA）
    2.SOA架构与MSA架构的区别
    3.微服务架构核心关注的问题是什么
    4.如何做微服务架构的技术选型
    5.目前架构正在朝着什么方向发展
    6.架构升级与业务发展的关系，一定要用最前卫的架构技术吗？什么样的架构才是好的架构
    7.微服务的难点是什么，这里主要留给大家思考，会在后续文章中进一步讲解
```
### [架构设计 | 接口幂等性原则，防重复提交Token管理](https://www.cnblogs.com/cicada-smile/p/12939875.html)
```markdown
幂等性概念
    幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。就是说，一次和多次请求某一个资源会产生同样的作用影响。
```
### [架构设计 | 缓存管理模式，监控和内存回收策略](https://www.cnblogs.com/cicada-smile/p/12968678.html)
#### 一、缓存设计
```markdown
缓存使用的基本原则：
    所有缓存数据，必须设置过期时间；
    核心业务流程不通过缓存层；
    缓存层移除，不影响现有流程；
    系统各个端首页数据不实时查询；
    报表数据不实时查询加载；
    归档数据(定时统计的结果数据)不实时查询；
缓存设计模式
    Cache-Aside模式:业务中最常用的缓存层设计模式。
        执行读操作未命中缓存，然后查询数据库中取数据，数据已经查询到还没放入缓存，同时一个更新写操作让缓存失效，
        然后读操作再把查询到数据加载缓存，导致缓存的脏数据。
    Read-Throug模式
        当应用系统向缓存系统请求数据时，如果缓存中并没有对应的数据存在，缓存系统将向底层数据源的读取数据。
        如果数据在缓存中存在，则直接返回缓存中存在的数据。把更新数据库的操作由缓存层代劳了。
    Write-Through模式
        更新写数据时，如果没有命中缓存，则直接更新数据库，如果命中了缓存，则先更新缓存，然后由缓存系统自行更新数据库。
    Write-Behind模式
        应用系统对缓存中的数据进行更新时，只更新缓存，不更新数据库，缓存系统会异步批量向底层数据源更新数据。
```
#### 二、数据一致问题
```markdown
业务开发模式中，会涉及到一个问题：如何最大限度保证数据库和Redis缓存的数据一致性？
首先说明一下：数据库和缓存强一致性同步成本太高，如果追求强一致，缓存层存在的价值就会很低，如上缓存模式一中几乎可以解决大部分业务场景问题。
方案一说明：
    - 数据库更新写入数据成功；
    - 准备一个先进先出模式的消息队列；
    - 把更新的数据包装为一个消息放入队列；
    - 基于消息消费服务更新Redis缓存；
分析：消息队列的稳定和可靠性，操作层面数据库和缓存层解耦。
方案二说明：
    - 提供一个数据库Binlog订阅服务，并解析修改日志；
    - 服务获取修改数据，并向Redis服务发送消息；
    - Redis数据进行修改，类似MySQL的主从同步机制；
分析：系统架构层面多出一个服务，且需要解析MySQL日志，操作难度较大，但流程上更为合理。
总结描述
分布式架构中，缓存层面的基本需求就是提高响应速度，不断优化，追求数据库和Redis缓存的数据快速一致性，从提供的各种方案中都可以看出，
这也在增加缓存层面处理的复杂性，架构逻辑复杂，就容易导致程序错误，所以针对业务选择合理的处理逻辑，这点很关键。
```
#### 三、缓存监控
```markdown
1、Redis服务监控
通过info命令查看Redis服务的参数信息，可以通过传参查看指定分类配置。通过config..set设置具体配置参数
2、LRU算法说明
Redis的数据是放在内存中的，所以速度快，自然也就受到内存大小的限制，如果内存使用超过配置，Redis有不同的回收处理策略。
```
[腾讯内容平台系统的架构实践](https://mp.weixin.qq.com/s/G26lg2xTClbuszYY7h0Dkw)
### [架构设计 | 异步处理流程，多种实现模式详解](https://www.cnblogs.com/cicada-smile/p/13046699.html)
[Java系统架构师学习体系图](https://www.cnblogs.com/niaobulashi/p/10979541.html)]【？？？？】
【随笔分类 - 架构设计】[架构设计](https://www.cnblogs.com/haoxiaozhang/category/1499749.html)
[聊聊微服务架构的优缺点](https://blog.csdn.net/claram/article/details/94552998)
[颠覆微服务认知：深入思考微服务的七个主流观点](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2651017655&idx=2&sn=d624d9f7fde60c4537bcd8105b8c91f7&chksm=bdbea9e48ac920f2809ed115fad11df7e31cced28fe57608cb9ffa4595e944ac7b377491a663&mpshare=1&scene=23&srcid=#rd)
[B站在微服务治理中的探索与实践](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2651017705&idx=5&sn=be713f43fb3196a319d26d527d3cd5cf&chksm=bdbea9ba8ac920ac3ad9eb494702ca94f110fdabe42a7d23914a741fb014cbc702649f08b14d&mpshare=1&scene=23&srcid=0713m32DWM0gUmjMweNuI7ev#rd)
[随笔分类 - 互联网架构实践心得](https://www.cnblogs.com/lovecindywang/category/1296779.html)

## 三、系统设计
### 领域驱动设计
[软件设计的目标和途径](https://www.cnblogs.com/linianhui/p/objective-and-approach-of-software-design.html)
【领域驱动设计】[DDD](https://www.cnblogs.com/Zachary-Fan/category/842270.html)
[后端开发实践系列之二——领域驱动设计(DDD)编码实践](https://www.cnblogs.com/davenkin/p/ddd-coding-practices.html)
### 限流
#### [Java分布式IP限流和防止恶意IP攻击方案]( https://www.cnblogs.com/hujunzheng/p/12593397.html )
#### [[微言限流](https://www.cnblogs.com/scy251147/p/9865099.html)]
#### [限流的6大狠招，附详细代码和评测结果](https://www.cnblogs.com/vipstone/p/12908918.html)
```markdown
流的分类如下所示：
1.合法性验证限流：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；
2.容器限流：比如Tomcat、Nginx 等限流手段，其中Tomcat可以设置最大线程数（maxThreads），
    当并发超过最大线程数会排队等待执行；而Nginx提供了两种限流手段：一是控制速率，二是控制并发连接数；
3.服务端限流：比如我们在服务器端通过限流算法实现限流，此项也是我们本文介绍的重点。
合法性验证限流为最常规的业务代码，就是普通的验证码和 IP 黑名单系统，本文就不做过多的叙述了。
重点来看下后两种限流的实现方案：容器限流和服务端限流。
    Tomcat 限流：Tomcat 8.5 版本的最大线程数在 conf/server.xml 配置中
    Nginx限流：Nginx提供了两种限流手段：一是控制速率，二是控制并发连接数。
        limit_req_zone用来限制单位时间内的请求数，即速率限制
        速率限制升级版 使用 burst 关键字开启此设置
        控制并发数:利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数
    服务端限流:需要配合限流的算法来执行，限流的常见算法:
        1.时间窗口算法:以当前时间为截止时间，往前取一定的时间，比如往前取60s的时间，在这60s之内运行最大的访问数为100，
            此时算法的执行逻辑为，先清除60s之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数100，
            如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。(Redis实现)
        2.漏桶算法：先声明一个队列用来保存请求，这个队列相当于漏斗，当队列容量满了之后就放弃新来的请求，
            然后重新声明一个线程定期从任务队列中获取一个或多个任务进行执行，这样就实现了漏桶算法。
            【Nginx 的控制速率其实使用的就是漏桶算法】，【可以借助 Redis 很方便的实现漏桶算法。】
        3.令牌算法：在令牌桶算法中有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，
            如果没有获取到令牌的请求可以选择等待或者放弃执行
```
#### [最近学习了限流相关的算法](https://www.cnblogs.com/hlkawa/p/13111003.html)
#### [稳定性五件套-限流的原理和实现](https://www.cnblogs.com/xiexj/p/13021294.html)
[接口限流看这一篇就够了！！！](https://www.cnblogs.com/Chenjiabing/p/12534346.html)
[微服务-高并发下接口如何做到优雅的限流](https://www.cnblogs.com/sy270321/p/12503504.html)
[最近学习了限流相关的算法](https://www.cnblogs.com/hlkawa/p/13111003.html)
[springboot + aop + Lua分布式限流的最佳实践](https://www.cnblogs.com/chengxy-nds/p/12661916.html)
#### 
### 理解RESTful设计
[理解RESTful：理论与最佳实践](https://www.cnblogs.com/yonghengzh/p/13750612.html)
[REST API 设计规范与最佳实践](https://github.com/Highflyer/REST_API_DESIGN_GUIDE)
### UML
[UML教程](https://www.cnblogs.com/jingmoxukong/p/10445894.html)

[错误码如何设计才合理？](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247497340&idx=1&sn=0a0ff30aff07c96a2ec677794be5373d&chksm=e92acb73de5d4265f2f26e32174ce6abefa72e2ec9953faf1da4b344b2c3fbf86822f48ddb32&mpshare=1&scene=23&srcid=&sharer_sharetime=1593529983872&sharer_shareid=d812adcc01829f0f7f8fb06aea118511#rd)

##
[git在工作中的用法总结-使用篇](https://www.cnblogs.com/fozero/p/10127902.html)

